
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">agenda-automator-api/cmd/server/main.go (40.0%)</option>
				
				<option value="file1">agenda-automator-api/internal/api/account/account.go (86.2%)</option>
				
				<option value="file2">agenda-automator-api/internal/api/auth/auth.go (25.0%)</option>
				
				<option value="file3">agenda-automator-api/internal/api/calendar/calendar.go (55.8%)</option>
				
				<option value="file4">agenda-automator-api/internal/api/common/common.go (69.1%)</option>
				
				<option value="file5">agenda-automator-api/internal/api/gmail/gmail.go (53.1%)</option>
				
				<option value="file6">agenda-automator-api/internal/api/health/health.go (100.0%)</option>
				
				<option value="file7">agenda-automator-api/internal/api/json.go (0.0%)</option>
				
				<option value="file8">agenda-automator-api/internal/api/log/log.go (80.0%)</option>
				
				<option value="file9">agenda-automator-api/internal/api/rule/rule.go (59.0%)</option>
				
				<option value="file10">agenda-automator-api/internal/api/server.go (39.7%)</option>
				
				<option value="file11">agenda-automator-api/internal/api/user/user.go (100.0%)</option>
				
				<option value="file12">agenda-automator-api/internal/crypto/crypto.go (83.9%)</option>
				
				<option value="file13">agenda-automator-api/internal/database/database.go (50.0%)</option>
				
				<option value="file14">agenda-automator-api/internal/database/migrations.go (100.0%)</option>
				
				<option value="file15">agenda-automator-api/internal/logger/logger.go (87.9%)</option>
				
				<option value="file16">agenda-automator-api/internal/store/account/account.go (78.1%)</option>
				
				<option value="file17">agenda-automator-api/internal/store/gmail/gmail.go (46.2%)</option>
				
				<option value="file18">agenda-automator-api/internal/store/log/log.go (96.6%)</option>
				
				<option value="file19">agenda-automator-api/internal/store/mock_store.go (0.0%)</option>
				
				<option value="file20">agenda-automator-api/internal/store/rule/rule.go (87.5%)</option>
				
				<option value="file21">agenda-automator-api/internal/store/store.go (100.0%)</option>
				
				<option value="file22">agenda-automator-api/internal/store/user/user.go (87.5%)</option>
				
				<option value="file23">agenda-automator-api/internal/worker/calendar/calendar.go (55.4%)</option>
				
				<option value="file24">agenda-automator-api/internal/worker/gmail/actions.go (6.8%)</option>
				
				<option value="file25">agenda-automator-api/internal/worker/gmail/gmail.go (53.6%)</option>
				
				<option value="file26">agenda-automator-api/internal/worker/gmail/helpers.go (45.9%)</option>
				
				<option value="file27">agenda-automator-api/internal/worker/gmail/processing.go (56.2%)</option>
				
				<option value="file28">agenda-automator-api/internal/worker/gmail/sync.go (47.8%)</option>
				
				<option value="file29">agenda-automator-api/internal/worker/worker.go (90.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "time"

        "net/http"
        "os"

        // Interne packages
        "agenda-automator-api/internal/api"
        "agenda-automator-api/internal/database"
        "agenda-automator-api/internal/logger"
        "agenda-automator-api/internal/store"
        "agenda-automator-api/internal/worker"

        // Externe packages

        "github.com/joho/godotenv"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
        "golang.org/x/oauth2/google"
)

func main() <span class="cov0" title="0">{
        // 1. Laad configuratie (.env)
        _ = godotenv.Load()

        // 1.5. Initialiseer logger
        log, err := logger.NewLogger()
        if err != nil </span><span class="cov0" title="0">{
                panic("Could not initialize logger: " + err.Error())</span>
        }
        <span class="cov0" title="0">defer log.Sync()

        // 2. Maak verbinding met de Database
        pool, err := database.ConnectDB(log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("could not connect to the database", zap.Error(err))
                os.Exit(1) // Gebruik os.Exit voor een schone exit
        }</span>
        <span class="cov0" title="0">defer pool.Close()

        // 2.5. Voer migraties uit
        if err = database.RunMigrations(context.Background(), pool, log); err != nil </span><span class="cov0" title="0">{
                log.Error("database migrations failed", zap.Error(err))
                os.Exit(1)
        }</span>

        // 3. Roep de testbare run() functie aan
        // We geven de *concrete* pool mee, maar run() accepteert de interface
        <span class="cov0" title="0">server, err := run(log, pool)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("application startup failed", zap.Error(err))
                os.Exit(1)
        }</span>

        // 4. Start de HTTP Server (op de voorgrond)
        <span class="cov0" title="0">log.Info("starting API server", zap.String("addr", server.Addr), zap.String("component", "main"))
        if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                log.Error("could not start server", zap.Error(err))
                os.Exit(1)
        }</span>
}

// run bevat alle testbare applicatie-opstartlogica.
// Het accepteert interfaces, wat het testbaar maakt.
func run(log *zap.Logger, pool database.Querier) (*http.Server, error) <span class="cov8" title="1">{
        // 3. Initialiseer de Gedeelde OAuth2 Config
        clientID := os.Getenv("GOOGLE_OAUTH_CLIENT_ID")
        clientSecret := os.Getenv("GOOGLE_OAUTH_CLIENT_SECRET")
        redirectURL := os.Getenv("OAUTH_REDIRECT_URL")

        if clientID == "" || clientSecret == "" || redirectURL == "" </span><span class="cov8" title="1">{
                log.Error("Google OAuth configuration missing", zap.String("component", "run"))
                // We retourneren een error zodat de test kan falen
                // FIX: Geen hoofdletter (ST1005)
                return nil, fmt.Errorf("google OAuth configuration missing")
        }</span>

        <span class="cov8" title="1">googleOAuthConfig := &amp;oauth2.Config{
                ClientID:     clientID,
                ClientSecret: clientSecret,
                RedirectURL:  redirectURL,
                Endpoint:     google.Endpoint,
                Scopes: []string{
                        // Calendar APIs
                        "https://www.googleapis.com/auth/calendar",
                        "https://www.googleapis.com/auth/calendar.events",

                        // Gmail APIs
                        "https://www.googleapis.com/auth/gmail.modify",
                        "https://www.googleapis.com/auth/gmail.compose",
                        "https://www.googleapis.com/auth/gmail.insert",
                        "https://www.googleapis.com/auth/gmail.labels",
                        "https://www.googleapis.com/auth/gmail.metadata",

                        // Google Drive API
                        "https://www.googleapis.com/auth/drive.file",

                        // Google People API
                        "https://www.googleapis.com/auth/contacts.readonly",

                        // User info
                        "https://www.googleapis.com/auth/userinfo.email",
                        "https://www.googleapis.com/auth/userinfo.profile",
                },
        }

        // 4. Initialiseer de 'Store' Laag
        // FIX: De broken convertPoolToPgxPool is verwijderd.
        // We geven de 'pool' (database.Querier) interface direct door.
        dbStore := store.NewStore(pool, googleOAuthConfig, log)

        // 5. Initialiseer de Worker
        appWorker, err := worker.NewWorker(dbStore, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("could not initialize worker", zap.Error(err))
                return nil, fmt.Errorf("could not initialize worker: %w", err)
        }</span>

        // 6. Start de Worker in de achtergrond
        <span class="cov8" title="1">appWorker.Start()

        // 7. Initialiseer de API Server
        apiServer := api.NewServer(dbStore, log, googleOAuthConfig)

        // 8. Maak de HTTP Server
        port := os.Getenv("API_PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080" // Default poort
        }</span>

        <span class="cov8" title="1">server := &amp;http.Server{
                Addr:         ":" + port,
                Handler:      apiServer.Router,
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 10 * time.Second,
                IdleTimeout:  120 * time.Second,
        }

        // 9. Return de server (main() zal ListenAndServe() aanroepen)
        return server, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package account

import (
        "net/http"

        "agenda-automator-api/internal/api/common"
        "agenda-automator-api/internal/store"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "go.uber.org/zap" // &lt;-- MOEST WORDEN TOEGEVOEGD
)

// HandleGetConnectedAccounts haalt alle gekoppelde accounts op voor de gebruiker.
// AANGEPAST: Accepteert nu *zap.Logger
func HandleGetConnectedAccounts(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov8" title="1">{
                        // AANGEPAST: log meegegeven
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log)
                        return
                }</span>

                <span class="cov8" title="1">accounts, err := store.GetAccountsForUser(r.Context(), userID)
                if err != nil </span><span class="cov8" title="1">{
                        // AANGEPAST: log meegegeven
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon accounts niet ophalen", log)
                        return
                }</span>

                // AANGEPAST: log meegegeven
                <span class="cov8" title="1">common.WriteJSON(w, http.StatusOK, accounts, log)</span>
        }
}

// HandleDeleteConnectedAccount verwijdert een gekoppeld account.
// AANGEPAST: Accepteert nu *zap.Logger
func HandleDeleteConnectedAccount(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        // AANGEPAST: log meegegeven
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log)
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        // AANGEPAST: log meegegeven
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log)
                        return
                }</span>

                <span class="cov8" title="1">account, err := store.GetConnectedAccountByID(r.Context(), accountID)
                if err != nil || account.UserID != userID </span><span class="cov8" title="1">{
                        // AANGEPAST: log meegegeven
                        common.WriteJSONError(w, http.StatusNotFound, "Account niet gevonden", log)
                        return
                }</span>

                <span class="cov8" title="1">err = store.DeleteConnectedAccount(r.Context(), accountID)
                if err != nil </span><span class="cov0" title="0">{
                        // AANGEPAST: log meegegeven
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon account niet verwijderen", log)
                        return
                }</span>

                // AANGEPAST: log meegegeven
                <span class="cov8" title="1">common.WriteJSON(w, http.StatusNoContent, nil, log)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "fmt"

        "agenda-automator-api/internal/api/common"
        "agenda-automator-api/internal/domain"
        "agenda-automator-api/internal/store"

        // "log" // &lt;-- VERWIJDERD
        "net/http"
        "os"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "go.uber.org/zap" // &lt;-- TOEGEVOEGD
        "golang.org/x/oauth2"
        oauth2v2 "google.golang.org/api/oauth2/v2"
        "google.golang.org/api/option"
)

const oauthStateCookieName = "oauthstate"

// generateJWT creert een nieuw JWT token voor een gebruiker
func generateJWT(userID uuid.UUID) (string, error) <span class="cov8" title="1">{
        jwtKey := []byte(os.Getenv("JWT_SECRET_KEY"))
        if len(jwtKey) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("JWT_SECRET_KEY is niet ingesteld")
        }</span>

        <span class="cov8" title="1">claims := jwt.MapClaims{
                "user_id": userID.String(),
                "iss":     "agenda-automator-api",
                "iat":     time.Now().Unix(),
                "exp":     time.Now().Add(time.Hour * 24 * 7).Unix(), // 7 dagen geldig
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(jwtKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("kon token niet ondertekenen: %w", err)
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

// HandleGoogleLogin starts the OAuth flow to Google.
func HandleGoogleLogin(oauthConfig *oauth2.Config, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                b := make([]byte, 32)
                if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{ // GOED
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon state niet genereren", log)
                        return
                }</span>
                <span class="cov8" title="1">state := base64.URLEncoding.EncodeToString(b)

                cookie := &amp;http.Cookie{
                        Name:     oauthStateCookieName,
                        Value:    state,
                        Path:     "/",
                        HttpOnly: true,
                        MaxAge:   60 * 10,
                }
                http.SetCookie(w, cookie)

                authURL := oauthConfig.AuthCodeURL(state, oauth2.AccessTypeOffline, oauth2.ApprovalForce)
                http.Redirect(w, r, authURL, http.StatusTemporaryRedirect)</span>
        }
}

// HandleGoogleCallback handles the callback from Google after login.
func HandleGoogleCallback(storer store.Storer, oauthConfig *oauth2.Config, log *zap.Logger) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                stateCookie, err := r.Cookie(oauthStateCookieName)
                if err != nil </span><span class="cov0" title="0">{
                        // AANGEPAST: log meegegeven
                        common.WriteJSONError(w, http.StatusBadRequest, "Geen state cookie", log)
                        return
                }</span>
                <span class="cov0" title="0">if r.URL.Query().Get("state") != stateCookie.Value </span><span class="cov0" title="0">{
                        // AANGEPAST: log meegegeven
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige state token", log)
                        return
                }</span>

                <span class="cov0" title="0">code := r.URL.Query().Get("code")
                token, err := oauthConfig.Exchange(ctx, code)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon code niet inwisselen: %s", err.Error()),
                                log,
                        )
                        return
                }</span>
                <span class="cov0" title="0">if token.RefreshToken == "" </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusBadRequest,
                                "Geen refresh token ontvangen. Probeer opnieuw.",
                                log,
                        )
                        return
                }</span>

                <span class="cov0" title="0">userInfo, err := getUserInfo(ctx, token)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon gebruikersinfo niet ophalen: %s", err.Error()),
                                log,
                        )
                        return
                }</span>

                <span class="cov0" title="0">user, err := storer.CreateUser(ctx, userInfo.Email, userInfo.Name)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon gebruiker niet aanmaken: %s", err.Error()),
                                log,
                        )
                        return
                }</span>

                <span class="cov0" title="0">params := store.UpsertConnectedAccountParams{
                        UserID:         user.ID,
                        Provider:       domain.ProviderGoogle,
                        Email:          userInfo.Email,
                        ProviderUserID: userInfo.Id,
                        AccessToken:    token.AccessToken,
                        RefreshToken:   token.RefreshToken,
                        TokenExpiry:    token.Expiry,
                        Scopes:         oauthConfig.Scopes,
                }

                account, err := storer.UpsertConnectedAccount(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon account niet koppelen: %s", err.Error()),
                                log,
                        )
                        return
                }</span>

                <span class="cov0" title="0">log.Info(
                        "Account gekoppeld",
                        zap.String("account_id", account.ID.String()),
                        zap.String("user_id", user.ID.String()),
                )

                jwtString, err := generateJWT(user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon authenticatie-token niet genereren: %s", err.Error()),
                                log,
                        )
                        return
                }</span>

                <span class="cov0" title="0">redirectURL := fmt.Sprintf("%s/dashboard?token=%s", os.Getenv("CLIENT_BASE_URL"), jwtString)
                http.Redirect(w, r, redirectURL, http.StatusSeeOther)</span>
        }
}

// getUserInfo haalt profielinfo op met een geldig token
func getUserInfo(ctx context.Context, token *oauth2.Token) (*oauth2v2.Userinfo, error) <span class="cov0" title="0">{
        client := oauth2.NewClient(ctx, oauth2.StaticTokenSource(token))
        oauth2Service, err := oauth2v2.NewService(ctx, option.WithHTTPClient(client))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userInfo, err := oauth2Service.Userinfo.Get().Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return userInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package calendar

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "agenda-automator-api/internal/api/common"
        "agenda-automator-api/internal/store"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "google.golang.org/api/calendar/v3"
)

const defaultCalendarID = "primary"

// HandleCreateEvent creates a new event in Google Calendar.
func HandleCreateEvent(store store.Storer, logger *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", logger) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">calendarID := r.URL.Query().Get("calendarId") // Ondersteun secundaire calendars
                if calendarID == "" </span><span class="cov8" title="1">{
                        calendarID = defaultCalendarID
                }</span>

                <span class="cov8" title="1">var req calendar.Event
                if err = json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige request body", logger) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">ctx := r.Context()
                client, err := common.GetCalendarClient(ctx, store, accountID, logger)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                "Kon calendar client niet initialiseren",
                                logger,
                        )
                        return
                }</span>

                <span class="cov8" title="1">createdEvent, err := client.Events.Insert(calendarID, &amp;req).Do()
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon event niet creren: %v", err),
                                logger,
                        )
                        return
                }</span>

                <span class="cov0" title="0">common.WriteJSON(w, http.StatusCreated, createdEvent, logger)</span> // &lt;-- AANGEPAST
        }
}

// HandleUpdateEvent updates an existing event.
func HandleUpdateEvent(store store.Storer, logger *zap.Logger) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                accountIDStr := chi.URLParam(r, "accountId")
                eventID := chi.URLParam(r, "eventId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", logger) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov0" title="0">calendarID := r.URL.Query().Get("calendarId") // Ondersteun secundaire calendars
                if calendarID == "" </span><span class="cov0" title="0">{
                        calendarID = defaultCalendarID
                }</span>

                <span class="cov0" title="0">var req calendar.Event
                if err = json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige request body", logger) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov0" title="0">ctx := r.Context()
                client, err := common.GetCalendarClient(ctx, store, accountID, logger)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                "Kon calendar client niet initialiseren",
                                logger,
                        )
                        return
                }</span>

                <span class="cov0" title="0">updatedEvent, err := client.Events.Update(calendarID, eventID, &amp;req).Do()
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon event niet updaten: %v", err),
                                logger,
                        )
                        return
                }</span>

                <span class="cov0" title="0">common.WriteJSON(w, http.StatusOK, updatedEvent, logger)</span> // &lt;-- AANGEPAST
        }
}

// HandleDeleteEvent deletes an event.
func HandleDeleteEvent(store store.Storer, logger *zap.Logger) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                accountIDStr := chi.URLParam(r, "accountId")
                eventID := chi.URLParam(r, "eventId")
                calendarID := r.URL.Query().Get("calendarId") // Optioneel param voor secundaire calendar
                if calendarID == "" </span><span class="cov0" title="0">{
                        calendarID = defaultCalendarID
                }</span>

                <span class="cov0" title="0">accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", logger) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov0" title="0">ctx := r.Context()
                client, err := common.GetCalendarClient(ctx, store, accountID, logger)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                "Kon calendar client niet initialiseren",
                                logger,
                        )
                        return
                }</span>

                <span class="cov0" title="0">err = client.Events.Delete(calendarID, eventID).Do()
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon event niet verwijderen: %v", err),
                                logger,
                        )
                        return
                }</span>

                <span class="cov0" title="0">common.WriteJSON(w, http.StatusNoContent, nil, logger)</span> // &lt;-- AANGEPAST
        }
}

// HandleGetCalendarEvents retrieves events (optional calendarId param).
func HandleGetCalendarEvents(store store.Storer, logger *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", logger) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">calendarID := r.URL.Query().Get("calendarId") // Nieuw: Ondersteun secundaire calendars
                if calendarID == "" </span><span class="cov8" title="1">{
                        calendarID = defaultCalendarID
                }</span>

                // -----------------------------------------------------------------
                // HIER IS DE CORRECTIE (VERVANG JE OUDE timeMin/timeMax)
                // -----------------------------------------------------------------
                <span class="cov8" title="1">timeMinStr := r.URL.Query().Get("timeMin")
                if timeMinStr == "" </span><span class="cov8" title="1">{
                        // Default op 'nu' als de frontend niets meegeeft
                        timeMinStr = time.Now().Format(time.RFC3339)
                }</span>

                <span class="cov8" title="1">timeMaxStr := r.URL.Query().Get("timeMax")
                if timeMaxStr == "" </span><span class="cov8" title="1">{
                        // Default op 3 maanden vooruit als de frontend niets meegeeft
                        timeMaxStr = time.Now().AddDate(0, 3, 0).Format(time.RFC3339)
                }</span>
                // -----------------------------------------------------------------

                <span class="cov8" title="1">ctx := r.Context()
                userID, _ := common.GetUserIDFromContext(ctx) // Get user ID for logging

                client, err := common.GetCalendarClient(ctx, store, accountID, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(
                                "failed to initialize calendar client",
                                zap.Error(err),
                                zap.String("account_id", accountID.String()),
                                zap.String("user_id", userID.String()),
                                zap.String("calendar_id", calendarID),
                                zap.String("component", "api"),
                        )
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                "Kon calendar client niet initialiseren",
                                logger,
                        )
                        return
                }</span>

                <span class="cov8" title="1">start := time.Now()
                events, err := client.Events.List(calendarID).
                        TimeMin(timeMinStr). // &lt;-- Gebruik de variabele
                        TimeMax(timeMaxStr). // &lt;-- Gebruik de variabele
                        SingleEvents(true).
                        OrderBy("startTime").
                        MaxResults(250). // &lt;-- VOEG DIT LIMIET TOE
                        Do()
                if err != nil </span><span class="cov8" title="1">{
                        duration := time.Since(start)
                        logger.Error(
                                "failed to fetch calendar events",
                                zap.Error(err),
                                zap.String("account_id", accountID.String()),
                                zap.String("user_id", userID.String()),
                                zap.String("calendar_id", calendarID),
                                zap.Int64("duration_ms", duration.Milliseconds()),
                                zap.String("component", "api"),
                        )
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon events niet ophalen: %v", err),
                                logger,
                        )
                        return
                }</span>

                <span class="cov0" title="0">duration := time.Since(start)
                logger.Info(
                        "successfully fetched calendar events",
                        zap.String("account_id", accountID.String()),
                        zap.String("user_id", userID.String()),
                        zap.String("calendar_id", calendarID),
                        zap.Int("event_count", len(events.Items)),
                        zap.Int64("duration_ms", duration.Milliseconds()),
                        zap.String("component", "api"),
                )

                common.WriteJSON(w, http.StatusOK, events.Items, logger)</span> // &lt;-- AANGEPAST
        }
}

// HandleListCalendars lists calendars for an account.
func HandleListCalendars(store store.Storer, logger *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", logger) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">ctx := r.Context()
                userID, _ := common.GetUserIDFromContext(ctx) // Get user ID for logging

                client, err := common.GetCalendarClient(ctx, store, accountID, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(
                                "failed to initialize calendar client",
                                zap.Error(err),
                                zap.String("account_id", accountID.String()),
                                zap.String("user_id", userID.String()),
                                zap.String("component", "api"),
                        )
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                "Kon calendar client niet initialiseren",
                                logger,
                        )
                        return
                }</span>

                <span class="cov8" title="1">start := time.Now()
                calendars, err := client.CalendarList.List().Do()
                if err != nil </span><span class="cov8" title="1">{
                        duration := time.Since(start)
                        logger.Error(
                                "failed to fetch calendars",
                                zap.Error(err),
                                zap.String("account_id", accountID.String()),
                                zap.String("user_id", userID.String()),
                                zap.Int64("duration_ms", duration.Milliseconds()),
                                zap.String("component", "api"),
                        )
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon calendars niet ophalen: %v", err),
                                logger,
                        )
                        return
                }</span>

                <span class="cov0" title="0">duration := time.Since(start)
                logger.Info(
                        "successfully fetched calendars",
                        zap.String("account_id", accountID.String()),
                        zap.String("user_id", userID.String()),
                        zap.Int("calendar_count", len(calendars.Items)),
                        zap.Int64("duration_ms", duration.Milliseconds()),
                        zap.String("component", "api"),
                )

                common.WriteJSON(w, http.StatusOK, calendars.Items, logger)</span> // &lt;-- AANGEPAST
        }
}

// HandleGetAggregatedEvents retrieves events across accounts/calendars.
func HandleGetAggregatedEvents(store store.Storer, logger *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), logger) // &lt;-- AANGEPAST
                        return
                }</span>

                // Parse request body: lijst van {accountId, calendarId} pairs
                <span class="cov8" title="1">type AggRequest struct {
                        Accounts []struct {
                                AccountID  string `json:"accountId"`
                                CalendarID string `json:"calendarId"`
                        } `json:"accounts"`
                }
                var req AggRequest
                if err = json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige request body", logger) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">timeMin := time.Now()
                timeMax := timeMin.AddDate(0, 3, 0)

                var allEvents []*calendar.Event
                ctx := r.Context()

                for _, acc := range req.Accounts </span><span class="cov8" title="1">{
                        accountID, err := uuid.Parse(acc.AccountID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip invalid
                        }

                        <span class="cov8" title="1">account, err := store.GetConnectedAccountByID(ctx, accountID)
                        if err != nil || account.UserID != userID </span><span class="cov0" title="0">{
                                continue</span> // Skip not found or not owned
                        }

                        <span class="cov8" title="1">client, err := common.GetCalendarClient(ctx, store, accountID, logger) // &lt;-- AANGEPAST
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">calID := acc.CalendarID
                        if calID == "" </span><span class="cov0" title="0">{
                                calID = defaultCalendarID
                        }</span>

                        <span class="cov8" title="1">events, err := client.Events.List(calID).
                                TimeMin(timeMin.Format(time.RFC3339)).
                                TimeMax(timeMax.Format(time.RFC3339)).
                                SingleEvents(true).
                                OrderBy("startTime").
                                Do()
                        if err != nil </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov0" title="0">allEvents = append(allEvents, events.Items...)</span>
                }

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusOK, allEvents, logger)</span> // &lt;-- AANGEPAST
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package common

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "agenda-automator-api/internal/store" // logger package was hier niet nodig

        "github.com/google/uuid"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
        "google.golang.org/api/calendar/v3"
        "google.golang.org/api/gmail/v1"
        "google.golang.org/api/option"
)

// contextKey for user ID
type contextKey string

var UserContextKey contextKey = "user_id"

// GetUserIDFromContext haalt de user ID op die door de middleware in de context is gezet
func GetUserIDFromContext(ctx context.Context) (uuid.UUID, error) <span class="cov8" title="1">{
        userID, ok := ctx.Value(UserContextKey).(uuid.UUID)
        if !ok </span><span class="cov8" title="1">{
                return uuid.Nil, fmt.Errorf("missing or invalid user ID in context")
        }</span>
        <span class="cov8" title="1">return userID, nil</span>
}

// WriteJSON schrijft een standaard JSON response
func WriteJSON(w http.ResponseWriter, status int, data interface{}, logger *zap.Logger) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                logger.Error(
                        "failed to write JSON response",
                        zap.Error(err),
                        zap.Int("status", status),
                        zap.String("component", "api"),
                )
        }</span>
}

// WriteJSONError schrijft een standaard JSON error response
func WriteJSONError(w http.ResponseWriter, status int, message string, logger *zap.Logger) <span class="cov8" title="1">{
        WriteJSON(w, status, map[string]string{"error": message}, logger)
}</span>

// getOAuthClient is a helper to get an OAuth2 HTTP client for Google APIs
func getOAuthClient(
        ctx context.Context,
        store store.Storer,
        accountID uuid.UUID,
        logger *zap.Logger,
) (*http.Client, error) <span class="cov0" title="0">{
        // BELANGRIJK: Gebruik context.Background() voor externe calls,
        // NIET de 'ctx' van de request, om header-vervuiling te voorkomen.
        cleanCtx := context.Background()

        // 1. Haal het token op (deze functie gebruikt de DB context 'ctx', maar 'cleanCtx' voor de refresh)
        token, err := store.GetValidTokenForAccount(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(
                        "failed to get valid token for OAuth client",
                        zap.Error(err),
                        zap.String("account_id", accountID.String()),
                        zap.String("component", "api"),
                )
                return nil, fmt.Errorf("kon geen geldig token voor account ophalen: %w", err)
        }</span>

        // 2. Maak de client aan met de schone context
        <span class="cov0" title="0">return oauth2.NewClient(cleanCtx, oauth2.StaticTokenSource(token)), nil</span>
}

// GetCalendarClient initialiseert een Google Calendar client met token refresh.
func GetCalendarClient(
        ctx context.Context,
        store store.Storer,
        accountID uuid.UUID,
        logger *zap.Logger,
) (*calendar.Service, error) <span class="cov0" title="0">{
        client, err := getOAuthClient(ctx, store, accountID, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cleanCtx := context.Background()
        return calendar.NewService(cleanCtx, option.WithHTTPClient(client))</span>
}

// GetGmailClient initialiseert een Google Gmail client met token refresh.
func GetGmailClient(
        ctx context.Context,
        store store.Storer,
        accountID uuid.UUID,
        logger *zap.Logger,
) (*gmail.Service, error) <span class="cov0" title="0">{
        client, err := getOAuthClient(ctx, store, accountID, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cleanCtx := context.Background()
        return gmail.NewService(cleanCtx, option.WithHTTPClient(client))</span>
}

// ParseEmailAddresses parses a comma-separated string of email addresses.
func ParseEmailAddresses(emailString string) []string <span class="cov8" title="1">{
        if emailString == "" </span><span class="cov8" title="1">{
                return []string{}
        }</span>

        // Simple parsing - split by comma and trim spaces
        // In a production app, you'd want more robust email parsing
        <span class="cov8" title="1">parts := strings.Split(emailString, ",")
        var emails []string
        for _, part := range parts </span><span class="cov8" title="1">{
                email := strings.TrimSpace(part)
                if email != "" </span><span class="cov8" title="1">{
                        emails = append(emails, email)
                }</span>
        }
        <span class="cov8" title="1">return emails</span>
}

// ExtractMessageBody extracts the message body from a Gmail message payload.
func ExtractMessageBody(payload *gmail.MessagePart) string <span class="cov8" title="1">{
        if payload == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        // If it's a simple message (no parts), return the body directly
        <span class="cov8" title="1">if payload.Body != nil &amp;&amp; payload.Body.Data != "" </span><span class="cov8" title="1">{
                data, err := base64.URLEncoding.DecodeString(payload.Body.Data)
                if err == nil </span><span class="cov8" title="1">{
                        return string(data)
                }</span>
        }

        // If it has parts, look for text/plain or text/html
        <span class="cov8" title="1">if payload.Parts != nil </span><span class="cov8" title="1">{
                for _, part := range payload.Parts </span><span class="cov8" title="1">{
                        // Skip attachments
                        if part.Filename != "" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Check for text/plain first
                        <span class="cov8" title="1">if part.MimeType == "text/plain" &amp;&amp; part.Body != nil &amp;&amp; part.Body.Data != "" </span><span class="cov8" title="1">{
                                data, err := base64.URLEncoding.DecodeString(part.Body.Data)
                                if err == nil </span><span class="cov8" title="1">{
                                        return string(data)
                                }</span>
                        }

                        // If no plain text, check for text/html
                        <span class="cov8" title="1">if part.MimeType == "text/html" &amp;&amp; part.Body != nil &amp;&amp; part.Body.Data != "" </span><span class="cov8" title="1">{
                                data, err := base64.URLEncoding.DecodeString(part.Body.Data)
                                if err == nil </span><span class="cov8" title="1">{
                                        // For HTML, we could strip tags, but for now return as-is
                                        return string(data)
                                }</span>
                        }

                        // Recursively check nested parts
                        <span class="cov8" title="1">if nestedBody := ExtractMessageBody(part); nestedBody != "" </span><span class="cov8" title="1">{
                                return nestedBody
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package gmail

import (
        "encoding/base64"
        "encoding/json"
        "fmt"

        "agenda-automator-api/internal/api/common"
        "agenda-automator-api/internal/domain"
        "agenda-automator-api/internal/store"

        // "log" // &lt;-- VERWIJDERD
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "go.uber.org/zap" // &lt;-- TOEGEVOEGD
        "google.golang.org/api/gmail/v1"
)

// HandleGetGmailMessages retrieves Gmail messages.
func HandleGetGmailMessages(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log) // &lt;-- log meegegeven
                        return
                }</span>

                // Query parameters
                <span class="cov8" title="1">query := r.URL.Query().Get("q") // Gmail search query
                labelIds := r.URL.Query()["labelIds"]
                maxResultsStr := r.URL.Query().Get("maxResults")
                maxResults := 50 // default
                if maxResultsStr != "" </span><span class="cov0" title="0">{
                        if parsed, perr := strconv.Atoi(maxResultsStr); perr == nil &amp;&amp; parsed &gt; 0 &amp;&amp; parsed &lt;= 500 </span><span class="cov0" title="0">{
                                maxResults = parsed
                        }</span>
                }

                <span class="cov8" title="1">ctx := r.Context()
                // AANGEPAST: log meegegeven (vereist aanpassing in common.GetGmailClient)
                client, err := common.GetGmailClient(ctx, store, accountID, log)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("HANDLER ERROR [getGmailClient]", zap.Error(err)) // &lt;-- AANGEPAST
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon Gmail client niet initialiseren", log)
                        return
                }</span>

                <span class="cov8" title="1">listCall := client.Users.Messages.List("me").MaxResults(int64(maxResults))
                if query != "" </span><span class="cov0" title="0">{
                        listCall = listCall.Q(query)
                }</span>
                <span class="cov8" title="1">if len(labelIds) &gt; 0 </span><span class="cov0" title="0">{
                        listCall = listCall.LabelIds(labelIds...)
                }</span>

                <span class="cov8" title="1">messages, err := listCall.Do()
                if err != nil </span><span class="cov8" title="1">{
                        log.Error("HANDLER ERROR [client.Users.Messages.List]", zap.Error(err))
                        common.WriteJSONError(
                                w,
                                http.StatusInternalServerError,
                                fmt.Sprintf("Kon berichten niet ophalen: %v", err),
                                log,
                        )
                        return
                }</span>

                // Transform Gmail API response to our expected format
                // Try to fetch full message details, fall back to metadata if scope doesn't allow
                <span class="cov0" title="0">var transformedMessages []map[string]interface{}
                for _, msg := range messages.Messages </span><span class="cov0" title="0">{
                        var fullMsg *gmail.Message
                        var err error

                        // Try to get full message first
                        fullMsg, err = client.Users.Messages.Get("me", msg.Id).Format("full").Do()
                        if err != nil </span><span class="cov0" title="0">{
                                // If full access fails (403), try metadata only
                                // This is expected when token only has gmail.metadata scope
                                fullMsg, err = client.Users.Messages.Get("me", msg.Id).
                                        Format("metadata").Do()
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Warn(
                                                "Error fetching message metadata",
                                                zap.String("msg_id", msg.Id),
                                                zap.Error(err),
                                        )
                                        continue</span>
                                }
                        }

                        // Extract headers
                        <span class="cov0" title="0">var subject, sender, to, cc, bcc string
                        var receivedAt time.Time
                        hasAttachments := false
                        isStarred := false

                        for _, header := range fullMsg.Payload.Headers </span><span class="cov0" title="0">{
                                switch header.Name </span>{
                                case "Subject":<span class="cov0" title="0">
                                        subject = header.Value</span>
                                case "From":<span class="cov0" title="0">
                                        sender = header.Value</span>
                                case "To":<span class="cov0" title="0">
                                        to = header.Value</span>
                                case "Cc":<span class="cov0" title="0">
                                        cc = header.Value</span>
                                case "Bcc":<span class="cov0" title="0">
                                        bcc = header.Value</span>
                                case "Date":<span class="cov0" title="0">
                                        if parsed, err := time.Parse(time.RFC1123Z, header.Value); err == nil </span><span class="cov0" title="0">{
                                                receivedAt = parsed
                                        }</span> else<span class="cov0" title="0"> if parsed, err := time.Parse("Mon, 02 Jan 2006 15:04:05 -0700", header.Value); err == nil </span><span class="cov0" title="0">{
                                                receivedAt = parsed
                                        }</span>
                                }
                        }

                        // Check for attachments
                        <span class="cov0" title="0">if fullMsg.Payload.Parts != nil </span><span class="cov0" title="0">{
                                for _, part := range fullMsg.Payload.Parts </span><span class="cov0" title="0">{
                                        if part.Filename != "" </span><span class="cov0" title="0">{
                                                hasAttachments = true
                                                break</span>
                                        }
                                }
                        }

                        // Check if starred
                        <span class="cov0" title="0">for _, labelID := range msg.LabelIds </span><span class="cov0" title="0">{
                                if labelID == "STARRED" </span><span class="cov0" title="0">{
                                        isStarred = true
                                        break</span>
                                }
                        }

                        // Determine status
                        <span class="cov0" title="0">status := "read"
                        for _, labelID := range msg.LabelIds </span><span class="cov0" title="0">{
                                if labelID == "UNREAD" </span><span class="cov0" title="0">{
                                        status = "unread"
                                        break</span>
                                }
                        }

                        // Extract message body (only available with full access)
                        <span class="cov0" title="0">var messageBody string
                        if fullMsg.Payload != nil &amp;&amp; fullMsg.Payload.Body != nil </span><span class="cov0" title="0">{
                                // We have full access, extract the body
                                messageBody = common.ExtractMessageBody(fullMsg.Payload)
                        }</span>
                        // If we only have metadata access, messageBody remains empty

                        // Parse recipients
                        <span class="cov0" title="0">var recipients, ccRecipients, bccRecipients []string
                        if to != "" </span><span class="cov0" title="0">{
                                recipients = common.ParseEmailAddresses(to)
                        }</span>
                        <span class="cov0" title="0">if cc != "" </span><span class="cov0" title="0">{
                                ccRecipients = common.ParseEmailAddresses(cc)
                        }</span>
                        <span class="cov0" title="0">if bcc != "" </span><span class="cov0" title="0">{
                                bccRecipients = common.ParseEmailAddresses(bcc)
                        }</span>

                        // Use snippet from metadata response if available, otherwise from list response
                        <span class="cov0" title="0">snippet := msg.Snippet
                        if fullMsg.Snippet != "" </span><span class="cov0" title="0">{
                                snippet = fullMsg.Snippet
                        }</span>

                        <span class="cov0" title="0">transformedMessages = append(transformedMessages, map[string]interface{}{
                                "id":               msg.Id,
                                "gmail_message_id": msg.Id,
                                "gmail_thread_id":  msg.ThreadId,
                                "subject":          subject,
                                "sender":           sender,
                                "recipients":       recipients,
                                "cc_recipients":    ccRecipients,
                                "bcc_recipients":   bccRecipients,
                                "snippet":          snippet,
                                "body":             messageBody,
                                "status":           status,
                                "is_starred":       isStarred,
                                "has_attachments":  hasAttachments,
                                "attachment_count": 0, // Would need deeper parsing for accurate count
                                "size_estimate":    fullMsg.SizeEstimate,
                                "received_at":      receivedAt.Format(time.RFC3339),
                                "labels":           msg.LabelIds,
                                "last_synced":      time.Now().Format(time.RFC3339),
                                "created_at":       time.Now().Format(time.RFC3339),
                                "updated_at":       time.Now().Format(time.RFC3339),
                        })</span>
                }

                <span class="cov0" title="0">common.WriteJSON(w, http.StatusOK, map[string]interface{}{
                        "messages": transformedMessages,
                }, log)</span> // &lt;-- log meegegeven
        }
}

// HandleSendGmailMessage sends an email using Gmail.
func HandleSendGmailMessage(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log)
                        return
                }</span>

                <span class="cov8" title="1">var req struct {
                        To      []string `json:"to"`
                        Cc      []string `json:"cc,omitempty"`
                        Bcc     []string `json:"bcc,omitempty"`
                        Subject string   `json:"subject"`
                        Body    string   `json:"body"`
                        IsHTML  bool     `json:"isHtml,omitempty"`
                }
                if err = json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige request body", log)
                        return
                }</span>

                <span class="cov8" title="1">ctx := r.Context()
                // AANGEPAST: log meegegeven
                client, err := common.GetGmailClient(ctx, store, accountID, log)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon Gmail client niet initialiseren", log)
                        return
                }</span>

                // Create the email message
                <span class="cov8" title="1">var message gmail.Message

                // For simplicity, we'll create a basic text message
                // In a full implementation, you'd want to properly encode MIME messages
                contentType := "text/plain"
                if req.IsHTML </span><span class="cov0" title="0">{
                        contentType = "text/html"
                }</span>

                // Build recipients string
                <span class="cov8" title="1">toRecipients := strings.Join(req.To, ",")
                var ccRecipients, bccRecipients string
                if len(req.Cc) &gt; 0 </span><span class="cov0" title="0">{
                        ccRecipients = "Cc: " + strings.Join(req.Cc, ",") + "\r\n"
                }</span>
                <span class="cov8" title="1">if len(req.Bcc) &gt; 0 </span><span class="cov0" title="0">{
                        bccRecipients = "Bcc: " + strings.Join(req.Bcc, ",") + "\r\n"
                }</span>

                // Create raw email content
                <span class="cov8" title="1">rawMessage := fmt.Sprintf("To: %s\r\n%s%sSubject: %s\r\nContent-Type: %s; charset=UTF-8\r\n\r\n%s",
                        toRecipients, ccRecipients, bccRecipients, req.Subject, contentType, req.Body)

                message.Raw = base64.URLEncoding.EncodeToString([]byte(rawMessage))

                sentMessage, err := client.Users.Messages.Send("me", &amp;message).Do()
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusInternalServerError, fmt.Sprintf("Kon email niet versturen: %v", err), log)
                        return
                }</span>

                <span class="cov0" title="0">common.WriteJSON(w, http.StatusOK, sentMessage, log)</span>
        }
}

// HandleGetGmailLabels retrieves Gmail labels.
func HandleGetGmailLabels(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log)
                        return
                }</span>

                <span class="cov8" title="1">ctx := r.Context()
                // AANGEPAST: log meegegeven
                client, err := common.GetGmailClient(ctx, store, accountID, log)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("HANDLER ERROR [getGmailClient]", zap.Error(err)) // &lt;-- AANGEPAST
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon Gmail client niet initialiseren", log)
                        return
                }</span>

                <span class="cov8" title="1">labels, err := client.Users.Labels.List("me").Do()
                if err != nil </span><span class="cov8" title="1">{
                        log.Error("HANDLER ERROR [client.Users.Labels.List]", zap.Error(err)) // &lt;-- AANGEPAST
                        common.WriteJSONError(w, http.StatusInternalServerError, fmt.Sprintf("Kon labels niet ophalen: %v", err), log)
                        return
                }</span>

                <span class="cov0" title="0">common.WriteJSON(w, http.StatusOK, map[string]interface{}{
                        "labels": labels.Labels,
                }, log)</span>
        }
}

// HandleCreateGmailDraft creates a Gmail draft.
func HandleCreateGmailDraft(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log)
                        return
                }</span>

                <span class="cov8" title="1">var req struct {
                        To      []string `json:"to"`
                        Cc      []string `json:"cc,omitempty"`
                        Bcc     []string `json:"bcc,omitempty"`
                        Subject string   `json:"subject"`
                        Body    string   `json:"body"`
                        IsHTML  bool     `json:"isHtml,omitempty"`
                }
                if err = json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige request body", log)
                        return
                }</span>

                <span class="cov8" title="1">ctx := r.Context()
                // AANGEPAST: log meegegeven
                client, err := common.GetGmailClient(ctx, store, accountID, log)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon Gmail client niet initialiseren", log)
                        return
                }</span>

                // Create draft message similar to send message
                <span class="cov8" title="1">var draft gmail.Draft
                var message gmail.Message

                contentType := "text/plain"
                if req.IsHTML </span><span class="cov0" title="0">{
                        contentType = "text/html"
                }</span>

                <span class="cov8" title="1">toRecipients := strings.Join(req.To, ",")
                var ccRecipients, bccRecipients string
                if len(req.Cc) &gt; 0 </span><span class="cov0" title="0">{
                        ccRecipients = "Cc: " + strings.Join(req.Cc, ",") + "\r\n"
                }</span>
                <span class="cov8" title="1">if len(req.Bcc) &gt; 0 </span><span class="cov0" title="0">{
                        bccRecipients = "Bcc: " + strings.Join(req.Bcc, ",") + "\r\n"
                }</span>

                <span class="cov8" title="1">rawMessage := fmt.Sprintf("To: %s\r\n%s%sSubject: %s\r\nContent-Type: %s; charset=UTF-8\r\n\r\n%s",
                        toRecipients, ccRecipients, bccRecipients, req.Subject, contentType, req.Body)

                message.Raw = base64.URLEncoding.EncodeToString([]byte(rawMessage))
                draft.Message = &amp;message

                createdDraft, err := client.Users.Drafts.Create("me", &amp;draft).Do()
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusInternalServerError, fmt.Sprintf("Kon draft niet creren: %v", err), log)
                        return
                }</span>

                <span class="cov0" title="0">common.WriteJSON(w, http.StatusCreated, createdDraft, log)</span>
        }
}

// HandleGetGmailDrafts retrieves Gmail drafts.
func HandleGetGmailDrafts(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log)
                        return
                }</span>

                <span class="cov8" title="1">ctx := r.Context()
                // AANGEPAST: log meegegeven
                client, err := common.GetGmailClient(ctx, store, accountID, log)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("HANDLER ERROR [getGmailClient]", zap.Error(err)) // &lt;-- AANGEPAST
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon Gmail client niet initialiseren", log)
                        return
                }</span>

                <span class="cov8" title="1">drafts, err := client.Users.Drafts.List("me").Do()
                if err != nil </span><span class="cov8" title="1">{
                        log.Error("HANDLER ERROR [client.Users.Drafts.List]", zap.Error(err)) // &lt;-- AANGEPAST
                        common.WriteJSONError(w, http.StatusInternalServerError, fmt.Sprintf("Kon drafts niet ophalen: %v", err), log)
                        return
                }</span>

                <span class="cov0" title="0">common.WriteJSON(w, http.StatusOK, map[string]interface{}{
                        "drafts": drafts.Drafts,
                }, log)</span>
        }
}

// HandleCreateGmailRule creert een nieuwe Gmail automation rule
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleCreateGmailRule(storer store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log)
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log)
                        return
                }</span>

                <span class="cov8" title="1">account, err := storer.GetConnectedAccountByID(r.Context(), accountID)
                if err != nil || account.UserID != userID </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusNotFound, "Account niet gevonden", log)
                        return
                }</span>

                <span class="cov8" title="1">var req domain.GmailAutomationRule
                if err = json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige request body", log)
                        return
                }</span>

                <span class="cov8" title="1">params := store.CreateGmailAutomationRuleParams{
                        ConnectedAccountID: accountID,
                        Name:               req.Name,
                        Description:        req.Description,
                        IsActive:           req.IsActive,
                        TriggerType:        req.TriggerType,
                        TriggerConditions:  req.TriggerConditions,
                        ActionType:         req.ActionType,
                        ActionParams:       req.ActionParams,
                        Priority:           req.Priority,
                }

                rule, err := storer.CreateGmailAutomationRule(r.Context(), params)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon Gmail rule niet creren", log)
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusCreated, rule, log)</span>
        }
}

// HandleGetGmailRules haalt Gmail automation rules op
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleGetGmailRules(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log)
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log)
                        return
                }</span>

                <span class="cov8" title="1">account, err := store.GetConnectedAccountByID(r.Context(), accountID)
                if err != nil || account.UserID != userID </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusNotFound, "Account niet gevonden", log)
                        return
                }</span>

                <span class="cov8" title="1">rules, err := store.GetGmailRulesForAccount(r.Context(), accountID)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon Gmail rules niet ophalen", log)
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusOK, rules, log)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package health

import (
        "net/http"

        "agenda-automator-api/internal/api/common"

        "go.uber.org/zap" // &lt;-- TOEGEVOEGD
)

// HandleHealth checks if the API server is running and healthy.
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleHealth(log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // AANGEPAST: log meegegeven
                common.WriteJSON(w, http.StatusOK, map[string]string{"status": "ok"}, log)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "encoding/json"
        "log"
        "net/http"
)

// WriteJSON schrijft een standaard JSON response
func WriteJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("could not write json response: %v", err)
        }</span>
}

// WriteJSONError schrijft een standaard JSON error response
func WriteJSONError(w http.ResponseWriter, status int, message string) <span class="cov0" title="0">{
        WriteJSON(w, status, map[string]string{"error": message})
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package log

import (
        "net/http"

        "agenda-automator-api/internal/api/common"
        "agenda-automator-api/internal/store"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "go.uber.org/zap" // &lt;-- TOEGEVOEGD
)

// HandleGetAutomationLogs haalt logs op voor een account.
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleGetAutomationLogs(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">account, err := store.GetConnectedAccountByID(r.Context(), accountID)
                if err != nil || account.UserID != userID </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusNotFound, "Account niet gevonden", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">limit := 50 // Default limit
                logs, err := store.GetLogsForAccount(r.Context(), accountID, limit)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon logs niet ophalen", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusOK, logs, log)</span> // &lt;-- AANGEPAST
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rule

import (
        "encoding/json"
        "net/http"

        "agenda-automator-api/internal/api/common"
        "agenda-automator-api/internal/domain"
        "agenda-automator-api/internal/store"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "go.uber.org/zap" // &lt;-- TOEGEVOEGD
)

// HandleCreateRule creert een nieuwe automation rule.
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleCreateRule(storer store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">account, err := storer.GetConnectedAccountByID(r.Context(), accountID)
                if err != nil || account.UserID != userID </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusNotFound, "Account niet gevonden", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">var req domain.AutomationRule
                if err = json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige request body", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">params := store.CreateAutomationRuleParams{
                        ConnectedAccountID: accountID,
                        Name:               req.Name,
                        TriggerConditions:  req.TriggerConditions,
                        ActionParams:       req.ActionParams,
                }

                rule, err := storer.CreateAutomationRule(r.Context(), params)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon rule niet creren", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusCreated, rule, log)</span> // &lt;-- AANGEPAST
        }
}

// HandleGetRules haalt alle rules op voor een account.
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleGetRules(storer store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accountIDStr := chi.URLParam(r, "accountId")
                accountID, err := uuid.Parse(accountIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig account ID", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">account, err := storer.GetConnectedAccountByID(r.Context(), accountID)
                if err != nil || account.UserID != userID </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusNotFound, "Account niet gevonden", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">rules, err := storer.GetRulesForAccount(r.Context(), accountID)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon rules niet ophalen", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusOK, rules, log)</span> // &lt;-- AANGEPAST
        }
}

// HandleUpdateRule update een bestaande rule.
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleUpdateRule(storer store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ruleIDStr := chi.URLParam(r, "ruleId")
                ruleID, err := uuid.Parse(ruleIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig rule ID", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">rule, err := storer.GetRuleByID(r.Context(), ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusNotFound, "Rule niet gevonden", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">account, err := storer.GetConnectedAccountByID(r.Context(), rule.ConnectedAccountID)
                if err != nil || account.UserID != userID </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusForbidden, "Geen toegang tot deze rule", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">var req domain.AutomationRule
                if err = json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldige request body", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">params := store.UpdateRuleParams{
                        RuleID:            ruleID,
                        Name:              req.Name,
                        TriggerConditions: req.TriggerConditions,
                        ActionParams:      req.ActionParams,
                }

                updatedRule, err := storer.UpdateRule(r.Context(), params)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon rule niet updaten", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusOK, updatedRule, log)</span> // &lt;-- AANGEPAST
        }
}

// HandleDeleteRule verwijdert een rule.
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleDeleteRule(storer store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ruleIDStr := chi.URLParam(r, "ruleId")
                ruleID, err := uuid.Parse(ruleIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig rule ID", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">rule, err := storer.GetRuleByID(r.Context(), ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusNotFound, "Rule niet gevonden", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">account, err := storer.GetConnectedAccountByID(r.Context(), rule.ConnectedAccountID)
                if err != nil || account.UserID != userID </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusForbidden, "Geen toegang tot deze rule", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">err = storer.DeleteRule(r.Context(), ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon rule niet verwijderen", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusNoContent, nil, log)</span> // &lt;-- AANGEPAST
        }
}

// HandleToggleRule togglet de active status van een rule.
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleToggleRule(storer store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ruleIDStr := chi.URLParam(r, "ruleId")
                ruleID, err := uuid.Parse(ruleIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusBadRequest, "Ongeldig rule ID", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">rule, err := storer.GetRuleByID(r.Context(), ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusNotFound, "Rule niet gevonden", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">account, err := storer.GetConnectedAccountByID(r.Context(), rule.ConnectedAccountID)
                if err != nil || account.UserID != userID </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusForbidden, "Geen toegang tot deze rule", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">updatedRule, err := storer.ToggleRuleStatus(r.Context(), ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon rule status niet togglen", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusOK, updatedRule, log)</span> // &lt;-- AANGEPAST
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "strings"

        "agenda-automator-api/internal/api/account"
        "agenda-automator-api/internal/api/auth"
        "agenda-automator-api/internal/api/calendar"
        "agenda-automator-api/internal/api/common"
        "agenda-automator-api/internal/api/gmail"
        "agenda-automator-api/internal/api/health"
        "agenda-automator-api/internal/api/log"
        "agenda-automator-api/internal/api/rule"
        "agenda-automator-api/internal/api/user"
        "agenda-automator-api/internal/store"

        "github.com/go-chi/chi/v5" // &lt;-- HIER ZAT DE TYPO
        "github.com/go-chi/cors"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
)

// VERWIJDERD: De helper GetUserIDFromContext stond al in common.go
// (Je kunt deze laten staan als je wilt, maar het is dubbel)

type Server struct {
        Router            *chi.Mux
        Store             store.Storer
        Logger            *zap.Logger
        GoogleOAuthConfig *oauth2.Config
}

func NewServer(s store.Storer, logger *zap.Logger, oauthConfig *oauth2.Config) *Server <span class="cov0" title="0">{
        server := &amp;Server{
                Router:            chi.NewRouter(),
                Store:             s,
                Logger:            logger,
                GoogleOAuthConfig: oauthConfig,
        }

        server.setupMiddleware()
        server.setupRoutes()

        return server
}</span>

func (s *Server) setupMiddleware() <span class="cov0" title="0">{
        allowedOrigins := strings.Split(os.Getenv("ALLOWED_ORIGINS"), ",")
        s.Router.Use(cors.Handler(cors.Options{
                AllowedOrigins:   allowedOrigins,
                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
                ExposedHeaders:   []string{"Link"},
                AllowCredentials: true,
                MaxAge:           300,
        }))
}</span>

func (s *Server) setupRoutes() <span class="cov0" title="0">{
        s.Router.Route("/api/v1", func(r chi.Router) </span><span class="cov0" title="0">{
                // Health check (unprotected)
                // AANGEPAST: health.HandleHealth accepteert nu ook de logger
                r.Get("/health", health.HandleHealth(s.Logger))

                // Auth routes
                // AANGEPAST: Doorgeven s.Logger
                r.Get("/auth/google/login", auth.HandleGoogleLogin(s.GoogleOAuthConfig, s.Logger))
                r.Get("/auth/google/callback", auth.HandleGoogleCallback(s.Store, s.GoogleOAuthConfig, s.Logger))

                // Protected routes
                r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Use(s.authMiddleware)

                        // User routes
                        // AANGEPAST: Logger wordt nu correct doorgegeven
                        r.Get("/me", user.HandleGetMe(s.Store, s.Logger))
                        r.Get("/users/me", user.HandleGetMe(s.Store, s.Logger))

                        // Account routes
                        // AANGEPAST: Doorgeven s.Logger
                        r.Get("/accounts", account.HandleGetConnectedAccounts(s.Store, s.Logger))
                        r.Delete("/accounts/{accountId}", account.HandleDeleteConnectedAccount(s.Store, s.Logger))

                        // Rule routes
                        // AANGEPAST: Doorgeven s.Logger
                        r.Post("/accounts/{accountId}/rules", rule.HandleCreateRule(s.Store, s.Logger))
                        r.Get("/accounts/{accountId}/rules", rule.HandleGetRules(s.Store, s.Logger))
                        r.Put("/rules/{ruleId}", rule.HandleUpdateRule(s.Store, s.Logger))
                        r.Delete("/rules/{ruleId}", rule.HandleDeleteRule(s.Store, s.Logger))
                        r.Put("/rules/{ruleId}/toggle", rule.HandleToggleRule(s.Store, s.Logger))

                        // Log routes
                        // AANGEPAST: Doorgeven s.Logger
                        r.Get("/accounts/{accountId}/logs", log.HandleGetAutomationLogs(s.Store, s.Logger))

                        // Calendar routes (waren al correct)
                        r.Get("/accounts/{accountId}/calendars", calendar.HandleListCalendars(s.Store, s.Logger))
                        r.Get("/accounts/{accountId}/calendar/events", calendar.HandleGetCalendarEvents(s.Store, s.Logger))
                        r.Post("/accounts/{accountId}/calendar/events", calendar.HandleCreateEvent(s.Store, s.Logger))
                        r.Put("/accounts/{accountId}/calendar/events/{eventId}", calendar.HandleUpdateEvent(s.Store, s.Logger))
                        r.Delete("/accounts/{accountId}/calendar/events/{eventId}", calendar.HandleDeleteEvent(s.Store, s.Logger))
                        r.Post("/calendar/aggregated-events", calendar.HandleGetAggregatedEvents(s.Store, s.Logger))

                        // Gmail routes
                        // AANGEPAST: Doorgeven s.Logger
                        r.Get("/accounts/{accountId}/gmail/messages", gmail.HandleGetGmailMessages(s.Store, s.Logger))
                        r.Post("/accounts/{accountId}/gmail/send", gmail.HandleSendGmailMessage(s.Store, s.Logger))
                        r.Get("/accounts/{accountId}/gmail/labels", gmail.HandleGetGmailLabels(s.Store, s.Logger))
                        r.Post("/accounts/{accountId}/gmail/drafts", gmail.HandleCreateGmailDraft(s.Store, s.Logger))
                        r.Get("/accounts/{accountId}/gmail/drafts", gmail.HandleGetGmailDrafts(s.Store, s.Logger))

                        // Gmail automation rules
                        // AANGEPAST: Doorgeven s.Logger
                        r.Post("/accounts/{accountId}/gmail/rules", gmail.HandleCreateGmailRule(s.Store, s.Logger))
                        r.Get("/accounts/{accountId}/gmail/rules", gmail.HandleGetGmailRules(s.Store, s.Logger))
                }</span>)
        })
}

// authMiddleware valideert JWT en zet user ID in context
func (s *Server) authMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        // AANGEPAST: s.Logger meegegeven
                        common.WriteJSONError(w, http.StatusUnauthorized, "Geen authenticatie header", s.Logger)
                        return
                }</span>

                <span class="cov8" title="1">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                jwtKey := []byte(os.Getenv("JWT_SECRET_KEY"))

                token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("ongeldige signing method")
                        }</span>
                        <span class="cov8" title="1">return jwtKey, nil</span>
                })

                <span class="cov8" title="1">if err != nil || !token.Valid </span><span class="cov8" title="1">{
                        // AANGEPAST: s.Logger meegegeven
                        common.WriteJSONError(w, http.StatusUnauthorized, "Ongeldige token", s.Logger)
                        return
                }</span>

                <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov0" title="0">{
                        // AANGEPAST: s.Logger meegegeven
                        common.WriteJSONError(w, http.StatusUnauthorized, "Ongeldige claims", s.Logger)
                        return
                }</span>

                <span class="cov8" title="1">userIDStr, ok := claims["user_id"].(string)
                if !ok </span><span class="cov8" title="1">{
                        // AANGEPAST: s.Logger meegegeven
                        common.WriteJSONError(w, http.StatusUnauthorized, "Geen user ID in token", s.Logger)
                        return
                }</span>

                <span class="cov8" title="1">userID, err := uuid.Parse(userIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        // AANGEPAST: s.Logger meegegeven
                        common.WriteJSONError(w, http.StatusUnauthorized, "Ongeldig user ID", s.Logger)
                        return
                }</span>

                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), common.UserContextKey, userID)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package user

import (
        "net/http"

        "agenda-automator-api/internal/api/common"
        "agenda-automator-api/internal/store"

        "go.uber.org/zap" // &lt;-- TOEGEVOEGD
)

// HandleGetMe haalt de gegevens op van de ingelogde gebruiker.
// AANGEPAST: Accepteert nu log *zap.Logger
func HandleGetMe(store store.Storer, log *zap.Logger) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                userID, err := common.GetUserIDFromContext(r.Context())
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusUnauthorized, err.Error(), log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">user, err := store.GetUserByID(r.Context(), userID)
                if err != nil </span><span class="cov8" title="1">{
                        common.WriteJSONError(w, http.StatusInternalServerError, "Kon gebruiker niet ophalen", log) // &lt;-- AANGEPAST
                        return
                }</span>

                <span class="cov8" title="1">common.WriteJSON(w, http.StatusOK, user, log)</span> // &lt;-- AANGEPAST
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package crypto

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "fmt"
        "io"
        "os"
)

// Encrypt versleutelt data met AES-GCM
func Encrypt(plaintext []byte) ([]byte, error) <span class="cov8" title="1">{
        key := []byte(os.Getenv("ENCRYPTION_KEY"))
        if len(key) != 32 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ENCRYPTION_KEY must be 32 bytes (AES-256)")
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
        return ciphertext, nil</span>
}

// Decrypt ontcijfert data met AES-GCM
func Decrypt(ciphertext []byte) ([]byte, error) <span class="cov8" title="1">{
        key := []byte(os.Getenv("ENCRYPTION_KEY"))
        if len(key) != 32 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ENCRYPTION_KEY must be 32 bytes (AES-256)")
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        if len(ciphertext) &lt; nonceSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ciphertext too short")
        }</span>

        <span class="cov8" title="1">nonce, actualCiphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]

        plaintext, err := gcm.Open(nil, nonce, actualCiphertext, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("decryption failed: %v", err)
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "context"
        "fmt"
        "os"
        "time"

        "agenda-automator-api/internal/logger"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
        "go.uber.org/zap"
)

// Querier defines the database operations used by stores and migrations
// Both *pgxpool.Pool and pgx.Tx implement this interface
type Querier interface {
        Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

// ConnectDB maakt en test een verbinding met de database.
func ConnectDB(log *zap.Logger) (*pgxpool.Pool, error) <span class="cov8" title="1">{
        start := time.Now()
        dbURL := os.Getenv("DATABASE_URL")
        log.Info("connecting to database", zap.String("component", "database"))
        if dbURL == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DATABASE_URL environment variable is not set")
        }</span>

        <span class="cov8" title="1">pool, err := pgxpool.New(context.Background(), dbURL)
        if err != nil </span><span class="cov8" title="1">{
                logger.LogDuration(
                        log,
                        "database_connection_pool_creation",
                        time.Since(start).Milliseconds(),
                        zap.Error(err),
                        zap.String("component", "database"),
                )
                return nil, fmt.Errorf("unable to create connection pool: %v", err)
        }</span>

        <span class="cov0" title="0">pingStart := time.Now()
        if err := pool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                pool.Close()
                logger.LogDuration(
                        log,
                        "database_ping",
                        time.Since(pingStart).Milliseconds(),
                        zap.Error(err),
                        zap.String("component", "database"),
                )
                return nil, fmt.Errorf("unable to connect to database: %v", err)
        }</span>

        <span class="cov0" title="0">totalDuration := time.Since(start)
        logger.LogDuration(log, "database_connection_total", totalDuration.Milliseconds(), zap.String("component", "database"))
        log.Info("successfully connected to database", zap.String("component", "database"))
        return pool, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package database

import (
        "context"
        "os"
        "strings"

        "agenda-automator-api/db/migrations"

        "go.uber.org/zap"
)

// RunMigrations voert de database migraties uit op basis van de env var
func RunMigrations(ctx context.Context, db Querier, log *zap.Logger) error <span class="cov8" title="1">{
        run := os.Getenv("RUN_MIGRATIONS")
        if !strings.EqualFold(run, "true") </span><span class="cov8" title="1">{
                log.Info("skipping migrations (RUN_MIGRATIONS is not 'true')", zap.String("component", "migrations"))
                return nil
        }</span>

        <span class="cov8" title="1">log.Info("running database migrations", zap.String("component", "migrations"))

        migrationSteps := []struct {
                name  string
                query string
        }{
                {"initial schema", migrations.InitialSchemaUp},
                {"Gmail schema", migrations.GmailSchemaUp},
                {"optimization indexes", migrations.OptimizationIndexesUp},
                {"table optimizations", migrations.TableOptimizationsUp},
                {"calendar optimizations", migrations.CalendarOptimizationsUp},
                {"connected accounts optimization", migrations.ConnectedAccountsOptimizationUp},
        }

        for _, step := range migrationSteps </span><span class="cov8" title="1">{
                if _, err := db.Exec(ctx, step.query); err != nil </span><span class="cov8" title="1">{
                        log.Error(step.name+" migration failed", zap.Error(err))
                        return err
                }</span>
                <span class="cov8" title="1">log.Info(step.name+" migration applied successfully", zap.String("component", "migrations"))</span>
        }

        <span class="cov8" title="1">log.Info("all database migrations applied successfully", zap.String("component", "migrations"))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package logger

import (
        "os"
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        lumberjack "gopkg.in/natefinch/lumberjack.v2"
)

// NewLogger creates a new logger based on environment
func NewLogger() (*zap.Logger, error) <span class="cov8" title="1">{
        env := strings.ToLower(os.Getenv("ENV"))
        if env == "" </span><span class="cov0" title="0">{
                env = "development"
        }</span>

        // Configure outputs
        <span class="cov8" title="1">var cores []zapcore.Core

        // Console output
        var consoleEncoder zapcore.Encoder
        if env == "production" </span><span class="cov8" title="1">{
                consoleEncoder = zapcore.NewJSONEncoder(zapcore.EncoderConfig{
                        TimeKey:        "timestamp",
                        LevelKey:       "level",
                        NameKey:        "logger",
                        CallerKey:      "caller",
                        FunctionKey:    zapcore.OmitKey,
                        MessageKey:     "message",
                        StacktraceKey:  "",
                        LineEnding:     zapcore.DefaultLineEnding,
                        EncodeLevel:    zapcore.LowercaseLevelEncoder,
                        EncodeTime:     zapcore.ISO8601TimeEncoder,
                        EncodeDuration: zapcore.MillisDurationEncoder,
                        EncodeCaller:   zapcore.ShortCallerEncoder,
                })
        }</span> else<span class="cov8" title="1"> {
                consoleEncoder = zapcore.NewConsoleEncoder(zapcore.EncoderConfig{
                        TimeKey:        "timestamp",
                        LevelKey:       "level",
                        NameKey:        "logger",
                        CallerKey:      "caller",
                        FunctionKey:    zapcore.OmitKey,
                        MessageKey:     "message",
                        StacktraceKey:  "",
                        LineEnding:     zapcore.DefaultLineEnding,
                        EncodeLevel:    zapcore.CapitalColorLevelEncoder,
                        EncodeTime:     zapcore.ISO8601TimeEncoder,
                        EncodeDuration: zapcore.MillisDurationEncoder,
                        EncodeCaller:   zapcore.ShortCallerEncoder,
                })
        }</span>

        // Always add console output
        <span class="cov8" title="1">cores = append(cores, zapcore.NewCore(consoleEncoder, zapcore.AddSync(os.Stdout), zap.InfoLevel))

        // File output if LOG_FILE is set
        logFile := os.Getenv("LOG_FILE")
        if logFile != "" </span><span class="cov0" title="0">{
                // Create lumberjack logger for file rotation
                lumberjackLogger := &amp;lumberjack.Logger{
                        Filename:   logFile,
                        MaxSize:    100, // megabytes
                        MaxBackups: 3,   // number of backups
                        MaxAge:     28,  // days
                        Compress:   true,
                }

                fileEncoder := zapcore.NewJSONEncoder(zapcore.EncoderConfig{
                        TimeKey:        "timestamp",
                        LevelKey:       "level",
                        NameKey:        "logger",
                        CallerKey:      "caller",
                        FunctionKey:    zapcore.OmitKey,
                        MessageKey:     "message",
                        StacktraceKey:  "stacktrace",
                        LineEnding:     zapcore.DefaultLineEnding,
                        EncodeLevel:    zapcore.LowercaseLevelEncoder,
                        EncodeTime:     zapcore.ISO8601TimeEncoder,
                        EncodeDuration: zapcore.MillisDurationEncoder,
                        EncodeCaller:   zapcore.ShortCallerEncoder,
                })

                cores = append(cores, zapcore.NewCore(fileEncoder, zapcore.AddSync(lumberjackLogger), zap.InfoLevel))
        }</span>

        // Set log level from environment
        <span class="cov8" title="1">logLevel := strings.ToLower(os.Getenv("LOG_LEVEL"))
        atomicLevel := zap.NewAtomicLevel()
        if logLevel != "" </span><span class="cov8" title="1">{
                var level zapcore.Level
                switch logLevel </span>{
                case "debug":<span class="cov8" title="1">
                        level = zapcore.DebugLevel</span>
                case "info":<span class="cov8" title="1">
                        level = zapcore.InfoLevel</span>
                case "warn", "warning":<span class="cov8" title="1">
                        level = zapcore.WarnLevel</span>
                case "error":<span class="cov8" title="1">
                        level = zapcore.ErrorLevel</span>
                case "fatal":<span class="cov8" title="1">
                        level = zapcore.FatalLevel</span>
                default:<span class="cov8" title="1">
                        level = zapcore.InfoLevel</span>
                }
                <span class="cov8" title="1">atomicLevel.SetLevel(level)</span>
        } else<span class="cov8" title="1"> {
                atomicLevel.SetLevel(zapcore.InfoLevel)
        }</span>

        // Create multi-core logger
        <span class="cov8" title="1">core := zapcore.NewTee(cores...)
        logger := zap.New(core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))

        return logger, nil</span>
}

// WithContext creates a logger with context fields
func WithContext(logger *zap.Logger, fields ...zap.Field) *zap.Logger <span class="cov8" title="1">{
        return logger.With(fields...)
}</span>

// LogDuration performance logging helper
func LogDuration(logger *zap.Logger, operation string, duration int64, fields ...zap.Field) <span class="cov8" title="1">{
        fields = append(fields, zap.String("operation", operation), zap.Int64("duration_ms", duration))
        logger.Info("operation completed", fields...)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package account

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "agenda-automator-api/internal/crypto"
        "agenda-automator-api/internal/database"
        "agenda-automator-api/internal/domain"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
)

// AccountStorer defines the interface for account store operations
type AccountStorer interface {
        UpsertConnectedAccount(ctx context.Context, arg UpsertConnectedAccountParams) (domain.ConnectedAccount, error)
        GetConnectedAccountByID(ctx context.Context, id uuid.UUID) (domain.ConnectedAccount, error)
        UpdateAccountTokens(ctx context.Context, arg UpdateAccountTokensParams) error
        UpdateAccountLastChecked(ctx context.Context, id uuid.UUID) error
        GetActiveAccounts(ctx context.Context) ([]domain.ConnectedAccount, error)
        GetAccountsForUser(ctx context.Context, userID uuid.UUID) ([]domain.ConnectedAccount, error)
        VerifyAccountOwnership(ctx context.Context, accountID uuid.UUID, userID uuid.UUID) error
        DeleteConnectedAccount(ctx context.Context, accountID uuid.UUID) error
        UpdateAccountStatus(ctx context.Context, id uuid.UUID, status domain.AccountStatus) error
        UpdateConnectedAccountToken(ctx context.Context, params UpdateConnectedAccountTokenParams) error
        GetValidTokenForAccount(ctx context.Context, accountID uuid.UUID) (*oauth2.Token, error)
}

// ErrTokenRevoked wordt gegooid als de gebruiker de toegang heeft ingetrokken.
var ErrTokenRevoked = fmt.Errorf("token access has been revoked by user")

// UpsertConnectedAccountParams (aangepast van Create)
type UpsertConnectedAccountParams struct {
        UserID         uuid.UUID
        Provider       domain.ProviderType
        Email          string
        ProviderUserID string
        AccessToken    string
        RefreshToken   string
        TokenExpiry    time.Time
        Scopes         []string
}

// UpdateAccountTokensParams ...
type UpdateAccountTokensParams struct {
        AccountID       uuid.UUID
        NewAccessToken  string
        NewRefreshToken string
        NewTokenExpiry  time.Time
}

// UpdateConnectedAccountTokenParams ...
type UpdateConnectedAccountTokenParams struct {
        ID           uuid.UUID
        AccessToken  []byte
        RefreshToken []byte
        TokenExpiry  time.Time
}

// AccountStore handles account-related database operations
type AccountStore struct {
        db                database.Querier
        googleOAuthConfig *oauth2.Config // Nodig om tokens te verversen
        logger            *zap.Logger
}

// NewAccountStore creates a new AccountStore
func NewAccountStore(db database.Querier, oauthCfg *oauth2.Config, logger *zap.Logger) AccountStorer <span class="cov8" title="1">{
        return &amp;AccountStore{
                db:                db,
                googleOAuthConfig: oauthCfg,
                logger:            logger,
        }
}</span>

// UpsertConnectedAccount versleutelt de tokens en slaat het account op (upsert).
func (s *AccountStore) UpsertConnectedAccount(
        ctx context.Context,
        arg UpsertConnectedAccountParams,
) (domain.ConnectedAccount, error) <span class="cov8" title="1">{
        encryptedAccessToken, err := crypto.Encrypt([]byte(arg.AccessToken))
        if err != nil </span><span class="cov0" title="0">{
                return domain.ConnectedAccount{}, fmt.Errorf("could not encrypt access token: %w", err)
        }</span>

        <span class="cov8" title="1">var encryptedRefreshToken []byte
        if arg.RefreshToken != "" </span><span class="cov8" title="1">{
                encryptedRefreshToken, err = crypto.Encrypt([]byte(arg.RefreshToken))
                if err != nil </span><span class="cov0" title="0">{
                        return domain.ConnectedAccount{}, fmt.Errorf("could not encrypt refresh token: %w", err)
                }</span>
        }

        <span class="cov8" title="1">query := `
    INSERT INTO connected_accounts (
        user_id, provider, email, provider_user_id,
        access_token, refresh_token, token_expiry, scopes, status
    ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, 'active'
    )
    ON CONFLICT (user_id, provider, provider_user_id)
    DO UPDATE SET
        access_token = EXCLUDED.access_token,
        refresh_token = EXCLUDED.refresh_token,
        token_expiry = EXCLUDED.token_expiry,
        scopes = EXCLUDED.scopes,
        status = 'active',
        updated_at = now()
    RETURNING id, user_id, provider, email, provider_user_id,
        access_token, refresh_token, token_expiry, scopes, status,
        created_at, updated_at, last_checked;
    `

        row := s.db.QueryRow(ctx, query,
                arg.UserID,
                arg.Provider,
                arg.Email,
                arg.ProviderUserID,
                encryptedAccessToken,
                encryptedRefreshToken,
                arg.TokenExpiry,
                arg.Scopes,
        )

        var acc domain.ConnectedAccount
        err = row.Scan(
                &amp;acc.ID,
                &amp;acc.UserID,
                &amp;acc.Provider,
                &amp;acc.Email,
                &amp;acc.ProviderUserID,
                &amp;acc.AccessToken,
                &amp;acc.RefreshToken,
                &amp;acc.TokenExpiry,
                &amp;acc.Scopes,
                &amp;acc.Status,
                &amp;acc.CreatedAt,
                &amp;acc.UpdatedAt,
                &amp;acc.LastChecked,
        )

        if err != nil </span><span class="cov0" title="0">{
                return domain.ConnectedAccount{}, fmt.Errorf("db scan error: %w", err)
        }</span>

        <span class="cov8" title="1">return acc, nil</span>
}

// GetConnectedAccountByID ...
func (s *AccountStore) GetConnectedAccountByID(ctx context.Context, id uuid.UUID) (domain.ConnectedAccount, error) <span class="cov8" title="1">{
        query := `
        SELECT id, user_id, provider, email, provider_user_id,
            access_token, refresh_token, token_expiry, scopes, status,
            created_at, updated_at, last_checked
        FROM connected_accounts
        WHERE id = $1
    `

        row := s.db.QueryRow(ctx, query, id)

        var acc domain.ConnectedAccount
        err := row.Scan(
                &amp;acc.ID,
                &amp;acc.UserID,
                &amp;acc.Provider,
                &amp;acc.Email,
                &amp;acc.ProviderUserID,
                &amp;acc.AccessToken,
                &amp;acc.RefreshToken,
                &amp;acc.TokenExpiry,
                &amp;acc.Scopes,
                &amp;acc.Status,
                &amp;acc.CreatedAt,
                &amp;acc.UpdatedAt,
                &amp;acc.LastChecked,
        )

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return domain.ConnectedAccount{}, fmt.Errorf("account not found")
                }</span>
                <span class="cov0" title="0">return domain.ConnectedAccount{}, fmt.Errorf("db scan error: %w", err)</span>
        }

        <span class="cov8" title="1">return acc, nil</span>
}

// UpdateAccountTokens ...
func (s *AccountStore) UpdateAccountTokens(ctx context.Context, arg UpdateAccountTokensParams) error <span class="cov8" title="1">{
        encryptedAccessToken, err := crypto.Encrypt([]byte(arg.NewAccessToken))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not encrypt new access token: %w", err)
        }</span>

        <span class="cov8" title="1">var encryptedRefreshToken []byte
        var query string
        var args []interface{}

        if arg.NewRefreshToken != "" </span><span class="cov8" title="1">{
                encryptedRefreshToken, err = crypto.Encrypt([]byte(arg.NewRefreshToken))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not encrypt new refresh token: %w", err)
                }</span>

                <span class="cov8" title="1">query = `
        UPDATE connected_accounts
        SET access_token = $1, refresh_token = $2, token_expiry = $3, updated_at = now()
        WHERE id = $4;
        `
                args = []interface{}{encryptedAccessToken, encryptedRefreshToken, arg.NewTokenExpiry, arg.AccountID}</span>
        } else<span class="cov0" title="0"> {
                query = `
        UPDATE connected_accounts
        SET access_token = $1, token_expiry = $2, updated_at = now()
        WHERE id = $3;
        `
                args = []interface{}{encryptedAccessToken, arg.NewTokenExpiry, arg.AccountID}
        }</span>

        <span class="cov8" title="1">cmdTag, err := s.db.Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db exec error: %w", err)
        }</span>

        <span class="cov8" title="1">if cmdTag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no account found with ID %s to update", arg.AccountID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateAccountLastChecked updates the last checked time for an account.
func (s *AccountStore) UpdateAccountLastChecked(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        query := `
    UPDATE connected_accounts
    SET last_checked = now(), updated_at = now()
    WHERE id = $1;
    `

        _, err := s.db.Exec(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db exec error: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetActiveAccounts haalt alle accounts op die de worker moet controleren
func (s *AccountStore) GetActiveAccounts(ctx context.Context) ([]domain.ConnectedAccount, error) <span class="cov8" title="1">{
        query := `
    SELECT id, user_id, provider, email, provider_user_id,
           access_token, refresh_token, token_expiry, scopes, status,
           created_at, updated_at, last_checked
    FROM connected_accounts
    WHERE status = 'active';
    `

        rows, err := s.db.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("db query error: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var accounts []domain.ConnectedAccount
        for rows.Next() </span><span class="cov8" title="1">{
                var acc domain.ConnectedAccount
                err := rows.Scan(
                        &amp;acc.ID,
                        &amp;acc.UserID,
                        &amp;acc.Provider,
                        &amp;acc.Email,
                        &amp;acc.ProviderUserID,
                        &amp;acc.AccessToken,
                        &amp;acc.RefreshToken,
                        &amp;acc.TokenExpiry,
                        &amp;acc.Scopes,
                        &amp;acc.Status,
                        &amp;acc.CreatedAt,
                        &amp;acc.UpdatedAt,
                        &amp;acc.LastChecked,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db row scan error: %w", err)
                }</span>
                <span class="cov8" title="1">accounts = append(accounts, acc)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("db rows error: %w", err)
        }</span>

        <span class="cov8" title="1">return accounts, nil</span>
}

// GetAccountsForUser haalt alle accounts op die eigendom zijn van een specifieke gebruiker
func (s *AccountStore) GetAccountsForUser(ctx context.Context, userID uuid.UUID) ([]domain.ConnectedAccount, error) <span class="cov8" title="1">{
        query := `
    SELECT id, user_id, provider, email, provider_user_id,
           access_token, refresh_token, token_expiry, scopes, status,
           created_at, updated_at, last_checked
    FROM connected_accounts
    WHERE user_id = $1
    ORDER BY created_at DESC;
    `

        rows, err := s.db.Query(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("db query error: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var accounts []domain.ConnectedAccount
        for rows.Next() </span><span class="cov8" title="1">{
                var acc domain.ConnectedAccount
                err := rows.Scan(
                        &amp;acc.ID,
                        &amp;acc.UserID,
                        &amp;acc.Provider,
                        &amp;acc.Email,
                        &amp;acc.ProviderUserID,
                        &amp;acc.AccessToken,
                        &amp;acc.RefreshToken,
                        &amp;acc.TokenExpiry,
                        &amp;acc.Scopes,
                        &amp;acc.Status,
                        &amp;acc.CreatedAt,
                        &amp;acc.UpdatedAt,
                        &amp;acc.LastChecked,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db row scan error: %w", err)
                }</span>
                <span class="cov8" title="1">accounts = append(accounts, acc)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("db rows error: %w", err)
        }</span>

        <span class="cov8" title="1">return accounts, nil</span>
}

// VerifyAccountOwnership controleert of een gebruiker eigenaar is van een account
func (s *AccountStore) VerifyAccountOwnership(ctx context.Context, accountID uuid.UUID, userID uuid.UUID) error <span class="cov8" title="1">{
        query := `
    SELECT 1
    FROM connected_accounts
    WHERE id = $1 AND user_id = $2
    LIMIT 1;
    `
        var exists int
        err := s.db.QueryRow(ctx, query, accountID, userID).Scan(&amp;exists)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return fmt.Errorf("forbidden: account not found or does not belong to user")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("db query error: %w", err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// DeleteConnectedAccount verwijdert een specifiek account en diens data.
func (s *AccountStore) DeleteConnectedAccount(ctx context.Context, accountID uuid.UUID) error <span class="cov8" title="1">{
        query := `DELETE FROM connected_accounts WHERE id = $1`
        cmdTag, err := s.db.Exec(ctx, query, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db exec error: %w", err)
        }</span>
        <span class="cov8" title="1">if cmdTag.RowsAffected() == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no account found with ID %s to delete", accountID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateAccountStatus updates the status of an account.
func (s *AccountStore) UpdateAccountStatus(ctx context.Context, id uuid.UUID, status domain.AccountStatus) error <span class="cov8" title="1">{
        query := `
    UPDATE connected_accounts
    SET status = $1, updated_at = now()
    WHERE id = $2;
    `
        _, err := s.db.Exec(ctx, query, status, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db exec error: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateConnectedAccountToken update access/refresh token.
func (s *AccountStore) UpdateConnectedAccountToken(
        ctx context.Context,
        params UpdateConnectedAccountTokenParams,
) error <span class="cov0" title="0">{
        _, err := s.db.Exec(ctx, `
                UPDATE connected_accounts
                SET access_token = $1, refresh_token = $2, token_expiry = $3, updated_at = now()
                WHERE id = $4
        `, params.AccessToken, params.RefreshToken, params.TokenExpiry, params.ID)
        return err
}</span>

// getDecryptedToken is een helper om de db struct om te zetten naar een oauth2.Token
func (s *AccountStore) getDecryptedToken(acc domain.ConnectedAccount) (*oauth2.Token, error) <span class="cov8" title="1">{
        plaintextAccessToken, err := crypto.Decrypt(acc.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not decrypt access token: %w", err)
        }</span>

        <span class="cov8" title="1">var plaintextRefreshToken []byte
        if len(acc.RefreshToken) &gt; 0 </span><span class="cov8" title="1">{
                plaintextRefreshToken, err = crypto.Decrypt(acc.RefreshToken)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not decrypt refresh token: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;oauth2.Token{
                AccessToken:  string(plaintextAccessToken),
                RefreshToken: string(plaintextRefreshToken),
                Expiry:       acc.TokenExpiry,
                TokenType:    "Bearer",
        }, nil</span>
}

// GetValidTokenForAccount is de centrale functie die een token ophaalt,
// en indien nodig ververst en opslaat.
func (s *AccountStore) GetValidTokenForAccount(ctx context.Context, accountID uuid.UUID) (*oauth2.Token, error) <span class="cov8" title="1">{
        // 1. Haal account op uit DB
        acc, err := s.GetConnectedAccountByID(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kon account niet ophalen: %w", err)
        }</span>

        // 2. Decrypt het token
        <span class="cov8" title="1">token, err := s.getDecryptedToken(acc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kon token niet decrypten: %w", err)
        }</span>

        // 3. Controleer of het (bijna) verlopen is
        <span class="cov8" title="1">if token.Valid() </span><span class="cov8" title="1">{
                return token, nil // Token is prima
        }</span>

        // 4. Token is verlopen, ververs het
        <span class="cov8" title="1">s.logger.Info(
                "token expired, refreshing",
                zap.String("account_id", acc.ID.String()),
                zap.String("user_id", acc.UserID.String()),
                zap.String("component", "store"),
        )

        // BELANGRIJK: Gebruik context.Background() voor de externe refresh-call.
        // De 'ctx' van de caller kan de 'Authorization' header van de API request bevatten,
        // wat de refresh call van oauth2 in de war brengt.
        cleanCtx := context.Background()

        ts := s.googleOAuthConfig.TokenSource(cleanCtx, token) // &lt;-- Gebruik cleanCtx
        newToken, err := ts.Token()
        if err != nil </span><span class="cov8" title="1">{
                // Vang 'invalid_grant'
                if strings.Contains(err.Error(), "invalid_grant") </span><span class="cov8" title="1">{
                        s.logger.Error(
                                "access revoked for account, setting status to revoked",
                                zap.String("account_id", acc.ID.String()),
                                zap.String("component", "store"),
                        )
                        if err = s.UpdateAccountStatus(ctx, acc.ID, domain.StatusRevoked); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error(
                                        "failed to update status for revoked account",
                                        zap.Error(err),
                                        zap.String("account_id", acc.ID.String()),
                                        zap.String("component", "store"),
                                )
                        }</span>
                        <span class="cov8" title="1">return nil, ErrTokenRevoked</span> // Gooi specifieke error
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("could not refresh token: %w", err)</span>
        }

        // 5. Sla het nieuwe token op
        // Als we GEEN nieuwe refresh token krijgen, hergebruik dan de oude
        <span class="cov8" title="1">if newToken.RefreshToken == "" </span><span class="cov0" title="0">{
                newToken.RefreshToken = token.RefreshToken
        }</span>

        <span class="cov8" title="1">err = s.UpdateAccountTokens(ctx, UpdateAccountTokensParams{
                AccountID:       acc.ID,
                NewAccessToken:  newToken.AccessToken,
                NewRefreshToken: newToken.RefreshToken, // Zorg dat we de nieuwe refresh token opslaan
                NewTokenExpiry:  newToken.Expiry,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kon ververst token niet opslaan: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info(
                "token successfully refreshed and saved",
                zap.String("account_id", acc.ID.String()),
                zap.String("component", "store"),
        )

        // 6. Geef het nieuwe, geldige token terug
        return newToken, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package gmail

import (
        "context"
        "encoding/json"
        "errors"
        "time"

        "agenda-automator-api/internal/database"
        "agenda-automator-api/internal/domain"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "go.uber.org/zap"
)

// CreateGmailAutomationRuleParams contains parameters for creating Gmail automation rules.
type CreateGmailAutomationRuleParams struct {
        ConnectedAccountID uuid.UUID
        Name               string
        Description        *string
        IsActive           bool
        TriggerType        domain.GmailRuleTriggerType
        TriggerConditions  json.RawMessage
        ActionType         domain.GmailRuleActionType
        ActionParams       json.RawMessage
        Priority           int
}

type UpdateGmailRuleParams struct {
        RuleID            uuid.UUID
        Name              string
        Description       *string
        TriggerType       domain.GmailRuleTriggerType
        TriggerConditions json.RawMessage
        ActionType        domain.GmailRuleActionType
        ActionParams      json.RawMessage
        Priority          int
}

type StoreGmailMessageParams struct {
        ConnectedAccountID uuid.UUID
        GmailMessageID     string
        GmailThreadID      string
        Subject            *string
        Sender             *string
        Recipients         []string
        CcRecipients       []string
        BccRecipients      []string
        Snippet            *string
        Status             domain.GmailMessageStatus
        IsStarred          bool
        HasAttachments     bool
        AttachmentCount    int
        SizeEstimate       *int64
        ReceivedAt         time.Time
        Labels             []string
}

// GmailStorer defines the interface for Gmail-related storage operations.
type GmailStorer interface {
        CreateGmailAutomationRule(ctx context.Context, arg CreateGmailAutomationRuleParams) (domain.GmailAutomationRule, error)
        GetGmailRulesForAccount(ctx context.Context, accountID uuid.UUID) ([]domain.GmailAutomationRule, error)
        UpdateGmailRule(ctx context.Context, arg UpdateGmailRuleParams) (domain.GmailAutomationRule, error)
        DeleteGmailRule(ctx context.Context, ruleID uuid.UUID) error
        ToggleGmailRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.GmailAutomationRule, error)
        StoreGmailMessage(ctx context.Context, arg StoreGmailMessageParams) error
        StoreGmailThread(ctx context.Context, arg StoreGmailThreadParams) error
        UpdateGmailMessageStatus(
                ctx context.Context,
                accountID uuid.UUID,
                messageID string,
                status domain.GmailMessageStatus,
        ) error
        GetGmailMessagesForAccount(ctx context.Context, accountID uuid.UUID, limit int) ([]domain.GmailMessage, error)
        UpdateGmailSyncState(ctx context.Context, accountID uuid.UUID, historyID string, lastSync time.Time) error
        GetGmailSyncState(ctx context.Context, accountID uuid.UUID) (historyID *string, lastSync *time.Time, err error)
}

type StoreGmailThreadParams struct {
        ConnectedAccountID uuid.UUID
        GmailThreadID      string
        Subject            *string
        Snippet            *string
        MessageCount       int
        HasUnread          bool
        LastMessageAt      time.Time
        Labels             []string
}

// GmailStore implements the GmailStorer interface.
// GmailStore handles Gmail-related database operations
type GmailStore struct {
        db  database.Querier
        log *zap.Logger
}

// NewGmailStore creates a new GmailStore
func NewGmailStore(db database.Querier, log *zap.Logger) GmailStorer <span class="cov8" title="1">{
        return &amp;GmailStore{
                db:  db,
                log: log.With(zap.String("component", "gmail_store")),
        }
}</span>

// CreateGmailAutomationRule creates a new Gmail automation rule.
func (s *GmailStore) CreateGmailAutomationRule(
        ctx context.Context,
        arg CreateGmailAutomationRuleParams,
) (domain.GmailAutomationRule, error) <span class="cov8" title="1">{
        query := `
                INSERT INTO gmail_automation_rules (
                        connected_account_id, name, description, is_active, trigger_type,
                        trigger_conditions, action_type, action_params, priority
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id, connected_account_id, name, description, is_active, trigger_type,
                          trigger_conditions, action_type, action_params, priority, created_at, updated_at;
        `

        row := s.db.QueryRow(ctx, query,
                arg.ConnectedAccountID, arg.Name, arg.Description, arg.IsActive, arg.TriggerType,
                arg.TriggerConditions, arg.ActionType, arg.ActionParams, arg.Priority,
        )

        var rule domain.GmailAutomationRule
        err := row.Scan(
                &amp;rule.ID, &amp;rule.ConnectedAccountID, &amp;rule.Name, &amp;rule.Description, &amp;rule.IsActive,
                &amp;rule.TriggerType, &amp;rule.TriggerConditions, &amp;rule.ActionType, &amp;rule.ActionParams,
                &amp;rule.Priority, &amp;rule.CreatedAt, &amp;rule.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return domain.GmailAutomationRule{}, err
        }</span>

        <span class="cov8" title="1">return rule, nil</span>
}

// GetGmailRulesForAccount gets all Gmail automation rules for an account.
func (s *GmailStore) GetGmailRulesForAccount(
        ctx context.Context,
        accountID uuid.UUID,
) ([]domain.GmailAutomationRule, error) <span class="cov8" title="1">{
        query := `
                SELECT id, connected_account_id, name, description, is_active, trigger_type,
                       trigger_conditions, action_type, action_params, priority, created_at, updated_at
                FROM gmail_automation_rules
                WHERE connected_account_id = $1
                ORDER BY priority DESC, created_at DESC;
        `

        rows, err := s.db.Query(ctx, query, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var rules []domain.GmailAutomationRule
        for rows.Next() </span><span class="cov8" title="1">{
                var rule domain.GmailAutomationRule
                err := rows.Scan(
                        &amp;rule.ID, &amp;rule.ConnectedAccountID, &amp;rule.Name, &amp;rule.Description, &amp;rule.IsActive,
                        &amp;rule.TriggerType, &amp;rule.TriggerConditions, &amp;rule.ActionType, &amp;rule.ActionParams,
                        &amp;rule.Priority, &amp;rule.CreatedAt, &amp;rule.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">rules = append(rules, rule)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return rules, nil</span>
}

// UpdateGmailRule updates an existing Gmail automation rule.
func (s *GmailStore) UpdateGmailRule(
        ctx context.Context,
        arg UpdateGmailRuleParams,
) (domain.GmailAutomationRule, error) <span class="cov0" title="0">{
        query := `
                UPDATE gmail_automation_rules
                SET name = $1, description = $2, trigger_type = $3, trigger_conditions = $4,
                    action_type = $5, action_params = $6, priority = $7, updated_at = now()
                WHERE id = $8
                RETURNING id, connected_account_id, name, description, is_active, trigger_type,
                          trigger_conditions, action_type, action_params, priority, created_at, updated_at;
        `

        row := s.db.QueryRow(ctx, query,
                arg.Name, arg.Description, arg.TriggerType, arg.TriggerConditions,
                arg.ActionType, arg.ActionParams, arg.Priority, arg.RuleID,
        )

        var rule domain.GmailAutomationRule
        err := row.Scan(
                &amp;rule.ID, &amp;rule.ConnectedAccountID, &amp;rule.Name, &amp;rule.Description, &amp;rule.IsActive,
                &amp;rule.TriggerType, &amp;rule.TriggerConditions, &amp;rule.ActionType, &amp;rule.ActionParams,
                &amp;rule.Priority, &amp;rule.CreatedAt, &amp;rule.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return domain.GmailAutomationRule{}, err
        }</span>

        <span class="cov0" title="0">return rule, nil</span>
}

// DeleteGmailRule deletes a Gmail automation rule
func (s *GmailStore) DeleteGmailRule(ctx context.Context, ruleID uuid.UUID) error <span class="cov8" title="1">{
        s.log.Info("Attempting to delete rule", zap.String("rule_id", ruleID.String()))

        query := `DELETE FROM gmail_automation_rules WHERE id = $1;`

        cmdTag, err := s.db.Exec(ctx, query, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed to delete rule", zap.Error(err), zap.String("rule_id", ruleID.String()))
                return err
        }</span>

        <span class="cov8" title="1">if cmdTag.RowsAffected() == 0 </span><span class="cov8" title="1">{
                s.log.Warn("No rule found to delete", zap.String("rule_id", ruleID.String()))
                return errors.New("no Gmail rule found with ID " + ruleID.String() + " to delete")
        }</span>

        <span class="cov8" title="1">s.log.Info("Successfully deleted rule", zap.String("rule_id", ruleID.String()))
        return nil</span>
}

// ToggleGmailRuleStatus toggles the active status of a Gmail automation rule
func (s *GmailStore) ToggleGmailRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.GmailAutomationRule, error) <span class="cov0" title="0">{
        query := `
                UPDATE gmail_automation_rules
                SET is_active = NOT is_active, updated_at = now()
                WHERE id = $1
                RETURNING id, connected_account_id, name, description, is_active, trigger_type,
                          trigger_conditions, action_type, action_params, priority, created_at, updated_at;
        `

        row := s.db.QueryRow(ctx, query, ruleID)

        var rule domain.GmailAutomationRule
        err := row.Scan(
                &amp;rule.ID, &amp;rule.ConnectedAccountID, &amp;rule.Name, &amp;rule.Description, &amp;rule.IsActive,
                &amp;rule.TriggerType, &amp;rule.TriggerConditions, &amp;rule.ActionType, &amp;rule.ActionParams,
                &amp;rule.Priority, &amp;rule.CreatedAt, &amp;rule.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return domain.GmailAutomationRule{}, err
        }</span>

        <span class="cov0" title="0">return rule, nil</span>
}

// StoreGmailMessage stores or updates a Gmail message
func (s *GmailStore) StoreGmailMessage(ctx context.Context, arg StoreGmailMessageParams) error <span class="cov8" title="1">{
        query := `
                INSERT INTO gmail_messages (
                        connected_account_id, gmail_message_id, gmail_thread_id, subject, sender,
                        recipients, cc_recipients, bcc_recipients, snippet, status, is_starred,
                        has_attachments, attachment_count, size_estimate, received_at, labels
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
                ON CONFLICT (connected_account_id, gmail_message_id)
                DO UPDATE SET
                        subject = EXCLUDED.subject,
                        sender = EXCLUDED.sender,
                        recipients = EXCLUDED.recipients,
                        cc_recipients = EXCLUDED.cc_recipients,
                        bcc_recipients = EXCLUDED.bcc_recipients,
                        snippet = EXCLUDED.snippet,
                        status = EXCLUDED.status,
                        is_starred = EXCLUDED.is_starred,
                        has_attachments = EXCLUDED.has_attachments,
                        attachment_count = EXCLUDED.attachment_count,
                        size_estimate = EXCLUDED.size_estimate,
                        labels = EXCLUDED.labels,
                        last_synced = now(),
                        updated_at = now();
        `

        _, err := s.db.Exec(ctx, query,
                arg.ConnectedAccountID, arg.GmailMessageID, arg.GmailThreadID, arg.Subject, arg.Sender,
                arg.Recipients, arg.CcRecipients, arg.BccRecipients, arg.Snippet, arg.Status, arg.IsStarred,
                arg.HasAttachments, arg.AttachmentCount, arg.SizeEstimate, arg.ReceivedAt, arg.Labels,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StoreGmailThread stores or updates a Gmail thread
func (s *GmailStore) StoreGmailThread(ctx context.Context, arg StoreGmailThreadParams) error <span class="cov0" title="0">{
        query := `
                INSERT INTO gmail_threads (
                        connected_account_id, gmail_thread_id, subject, snippet, message_count,
                        has_unread, last_message_at, labels
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                ON CONFLICT (connected_account_id, gmail_thread_id)
                DO UPDATE SET
                        subject = EXCLUDED.subject,
                        snippet = EXCLUDED.snippet,
                        message_count = EXCLUDED.message_count,
                        has_unread = EXCLUDED.has_unread,
                        last_message_at = EXCLUDED.last_message_at,
                        labels = EXCLUDED.labels,
                        last_synced = now(),
                        updated_at = now();
        `

        _, err := s.db.Exec(ctx, query,
                arg.ConnectedAccountID, arg.GmailThreadID, arg.Subject, arg.Snippet,
                arg.MessageCount, arg.HasUnread, arg.LastMessageAt, arg.Labels,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateGmailMessageStatus updates the status of a Gmail message.
func (s *GmailStore) UpdateGmailMessageStatus(
        ctx context.Context,
        accountID uuid.UUID,
        messageID string,
        status domain.GmailMessageStatus,
) error <span class="cov0" title="0">{
        query := `
                UPDATE gmail_messages
                SET status = $1, updated_at = now()
                WHERE connected_account_id = $2 AND gmail_message_id = $3;
        `

        cmdTag, err := s.db.Exec(ctx, query, status, accountID, messageID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cmdTag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return errors.New("no message found with ID " + messageID + " for account " + accountID.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetGmailMessagesForAccount gets recent Gmail messages for an account.
func (s *GmailStore) GetGmailMessagesForAccount(
        ctx context.Context,
        accountID uuid.UUID,
        limit int,
) ([]domain.GmailMessage, error) <span class="cov0" title="0">{
        query := `
                SELECT id, connected_account_id, gmail_message_id, gmail_thread_id, subject, sender,
                       recipients, cc_recipients, bcc_recipients, snippet, status, is_starred,
                       has_attachments, attachment_count, size_estimate, received_at, labels,
                       last_synced, created_at, updated_at
                FROM gmail_messages
                WHERE connected_account_id = $1
                ORDER BY received_at DESC
                LIMIT $2;
        `

        rows, err := s.db.Query(ctx, query, accountID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var messages []domain.GmailMessage
        for rows.Next() </span><span class="cov0" title="0">{
                var msg domain.GmailMessage
                err := rows.Scan(
                        &amp;msg.ID, &amp;msg.ConnectedAccountID, &amp;msg.GmailMessageID, &amp;msg.GmailThreadID,
                        &amp;msg.Subject, &amp;msg.Sender, &amp;msg.Recipients, &amp;msg.CcRecipients, &amp;msg.BccRecipients,
                        &amp;msg.Snippet, &amp;msg.Status, &amp;msg.IsStarred, &amp;msg.HasAttachments, &amp;msg.AttachmentCount,
                        &amp;msg.SizeEstimate, &amp;msg.ReceivedAt, &amp;msg.Labels, &amp;msg.LastSynced, &amp;msg.CreatedAt, &amp;msg.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">messages = append(messages, msg)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return messages, nil</span>
}

// UpdateGmailSyncState updates the Gmail sync state for an account.
func (s *GmailStore) UpdateGmailSyncState(
        ctx context.Context,
        accountID uuid.UUID,
        historyID string,
        lastSync time.Time,
) error <span class="cov8" title="1">{
        query := `
                UPDATE connected_accounts
                SET gmail_history_id = $1, gmail_last_sync = $2, updated_at = now()
                WHERE id = $3;
        `

        _, err := s.db.Exec(ctx, query, historyID, lastSync, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetGmailSyncState gets the Gmail sync state for an account.
func (s *GmailStore) GetGmailSyncState(
        ctx context.Context,
        accountID uuid.UUID,
) (historyID *string, lastSync *time.Time, err error) <span class="cov8" title="1">{
        query := `
                SELECT gmail_history_id, gmail_last_sync
                FROM connected_accounts
                WHERE id = $1;
        `

        row := s.db.QueryRow(ctx, query, accountID)
        err = row.Scan(&amp;historyID, &amp;lastSync)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, nil, errors.New("account not found")
                }</span>
                <span class="cov0" title="0">return nil, nil, err</span>
        }

        <span class="cov8" title="1">return historyID, lastSync, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package log

import (
        "context"
        "encoding/json"
        "errors"

        "agenda-automator-api/internal/domain"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

// DBPool defines the database operations used by LogStore
type DBPool interface {
        Exec(ctx context.Context, sql string, args ...interface{}) (pgconn.CommandTag, error)
        QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
        Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
}

// LogStorer defines the interface for log storage operations.
type LogStorer interface {
        CreateAutomationLog(ctx context.Context, arg CreateLogParams) error
        HasLogForTrigger(ctx context.Context, ruleID uuid.UUID, triggerEventID string) (bool, error)
        GetLogsForAccount(ctx context.Context, accountID uuid.UUID, limit int) ([]domain.AutomationLog, error)
}

// CreateLogParams contains parameters for creating automation logs.
type CreateLogParams struct {
        ConnectedAccountID uuid.UUID
        RuleID             *uuid.UUID // Optional, can be nil
        Status             domain.AutomationLogStatus
        TriggerDetails     json.RawMessage // []byte
        ActionDetails      json.RawMessage // []byte
        ErrorMessage       string
}

// LogStore implements the LogStorer interface.
// LogStore handles log-related database operations
type LogStore struct {
        pool DBPool
}

// NewLogStore creates a new LogStore
func NewLogStore(pool DBPool) LogStorer <span class="cov8" title="1">{
        return &amp;LogStore{pool: pool}
}</span>

// CreateAutomationLog creates a new automation log.
func (s *LogStore) CreateAutomationLog(ctx context.Context, arg CreateLogParams) error <span class="cov8" title="1">{
        query := `
    INSERT INTO automation_logs (
        connected_account_id, rule_id, status, trigger_details, action_details, error_message
    ) VALUES ($1, $2, $3, $4, $5, $6);
    `
        _, err := s.pool.Exec(ctx, query,
                arg.ConnectedAccountID,
                arg.RuleID, // This can be NULL if arg.RuleID is nil
                arg.Status,
                arg.TriggerDetails,
                arg.ActionDetails,
                arg.ErrorMessage,
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// HasLogForTrigger checks if a log exists for a trigger event.
func (s *LogStore) HasLogForTrigger(ctx context.Context, ruleID uuid.UUID, triggerEventID string) (bool, error) <span class="cov8" title="1">{
        query := `
    SELECT 1
    FROM automation_logs
    WHERE rule_id = $1
      AND status = 'success'
      AND trigger_details-&gt;&gt;'google_event_id' = $2
    LIMIT 1;
    `
        var exists int
        err := s.pool.QueryRow(ctx, query, ruleID, triggerEventID).Scan(&amp;exists)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return false, nil // Geen log gevonden, dit is geen error
                }</span>
                <span class="cov8" title="1">return false, err</span> // Een echte error
        }

        <span class="cov8" title="1">return true, nil</span> // Gevonden
}

// GetLogsForAccount haalt de meest recente logs op voor een account.
func (s *LogStore) GetLogsForAccount(
        ctx context.Context,
        accountID uuid.UUID,
        limit int,
) ([]domain.AutomationLog, error) <span class="cov8" title="1">{
        query := `
           SELECT id, connected_account_id, rule_id, timestamp, status,
                  trigger_details, action_details, error_message
           FROM automation_logs
           WHERE connected_account_id = $1
           ORDER BY timestamp DESC
           LIMIT $2;
           `

        rows, err := s.pool.Query(ctx, query, accountID, limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var logs []domain.AutomationLog
        for rows.Next() </span><span class="cov8" title="1">{
                var log domain.AutomationLog
                err := rows.Scan(
                        &amp;log.ID,
                        &amp;log.ConnectedAccountID,
                        &amp;log.RuleID,
                        &amp;log.Timestamp,
                        &amp;log.Status,
                        &amp;log.TriggerDetails,
                        &amp;log.ActionDetails,
                        &amp;log.ErrorMessage,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">logs = append(logs, log)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return logs, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package store

import (
        "context"
        "time"

        "agenda-automator-api/internal/domain"

        "github.com/google/uuid"
        "github.com/stretchr/testify/mock"
        "golang.org/x/oauth2"
)

// MockStore is a mock implementation of the Storer interface for testing
type MockStore struct {
        mock.Mock
}

// CreateUser mocks the CreateUser method
func (m *MockStore) CreateUser(ctx context.Context, email, name string) (domain.User, error) <span class="cov0" title="0">{
        args := m.Called(ctx, email, name)
        return args.Get(0).(domain.User), args.Error(1)
}</span>

// GetUserByID mocks the GetUserByID method
func (m *MockStore) GetUserByID(ctx context.Context, userID uuid.UUID) (domain.User, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID)
        return args.Get(0).(domain.User), args.Error(1)
}</span>

// DeleteUser mocks the DeleteUser method
func (m *MockStore) DeleteUser(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, userID)
        return args.Error(0)
}</span>

// UpsertConnectedAccount mocks the UpsertConnectedAccount method.
func (m *MockStore) UpsertConnectedAccount(
        ctx context.Context,
        arg UpsertConnectedAccountParams,
) (domain.ConnectedAccount, error) <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Get(0).(domain.ConnectedAccount), args.Error(1)
}</span>

// GetConnectedAccountByID mocks the GetConnectedAccountByID method
func (m *MockStore) GetConnectedAccountByID(ctx context.Context, id uuid.UUID) (domain.ConnectedAccount, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Get(0).(domain.ConnectedAccount), args.Error(1)
}</span>

// GetActiveAccounts mocks the GetActiveAccounts method
func (m *MockStore) GetActiveAccounts(ctx context.Context) ([]domain.ConnectedAccount, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.Get(0).([]domain.ConnectedAccount), args.Error(1)
}</span>

// GetAccountsForUser mocks the GetAccountsForUser method
func (m *MockStore) GetAccountsForUser(ctx context.Context, userID uuid.UUID) ([]domain.ConnectedAccount, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID)
        return args.Get(0).([]domain.ConnectedAccount), args.Error(1)
}</span>

// UpdateAccountTokens mocks the UpdateAccountTokens method
func (m *MockStore) UpdateAccountTokens(ctx context.Context, arg UpdateAccountTokensParams) error <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Error(0)
}</span>

// UpdateAccountLastChecked mocks the UpdateAccountLastChecked method
func (m *MockStore) UpdateAccountLastChecked(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Error(0)
}</span>

// UpdateAccountStatus mocks the UpdateAccountStatus method
func (m *MockStore) UpdateAccountStatus(ctx context.Context, id uuid.UUID, status domain.AccountStatus) error <span class="cov0" title="0">{
        args := m.Called(ctx, id, status)
        return args.Error(0)
}</span>

// DeleteConnectedAccount mocks the DeleteConnectedAccount method
func (m *MockStore) DeleteConnectedAccount(ctx context.Context, accountID uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, accountID)
        return args.Error(0)
}</span>

// VerifyAccountOwnership mocks the VerifyAccountOwnership method
func (m *MockStore) VerifyAccountOwnership(ctx context.Context, accountID uuid.UUID, userID uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, accountID, userID)
        return args.Error(0)
}</span>

// CreateAutomationRule mocks the CreateAutomationRule method.
func (m *MockStore) CreateAutomationRule(
        ctx context.Context,
        arg CreateAutomationRuleParams,
) (domain.AutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Get(0).(domain.AutomationRule), args.Error(1)
}</span>

// GetRuleByID mocks the GetRuleByID method
func (m *MockStore) GetRuleByID(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, ruleID)
        return args.Get(0).(domain.AutomationRule), args.Error(1)
}</span>

// GetRulesForAccount mocks the GetRulesForAccount method
func (m *MockStore) GetRulesForAccount(ctx context.Context, accountID uuid.UUID) ([]domain.AutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, accountID)
        return args.Get(0).([]domain.AutomationRule), args.Error(1)
}</span>

// UpdateRule mocks the UpdateRule method
func (m *MockStore) UpdateRule(ctx context.Context, arg UpdateRuleParams) (domain.AutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Get(0).(domain.AutomationRule), args.Error(1)
}</span>

// ToggleRuleStatus mocks the ToggleRuleStatus method
func (m *MockStore) ToggleRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, ruleID)
        return args.Get(0).(domain.AutomationRule), args.Error(1)
}</span>

// DeleteRule mocks the DeleteRule method
func (m *MockStore) DeleteRule(ctx context.Context, ruleID uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, ruleID)
        return args.Error(0)
}</span>

// VerifyRuleOwnership mocks the VerifyRuleOwnership method
func (m *MockStore) VerifyRuleOwnership(ctx context.Context, ruleID uuid.UUID, userID uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, ruleID, userID)
        return args.Error(0)
}</span>

// CreateAutomationLog mocks the CreateAutomationLog method
func (m *MockStore) CreateAutomationLog(ctx context.Context, arg CreateLogParams) error <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Error(0)
}</span>

// HasLogForTrigger mocks the HasLogForTrigger method
func (m *MockStore) HasLogForTrigger(ctx context.Context, ruleID uuid.UUID, triggerEventID string) (bool, error) <span class="cov0" title="0">{
        args := m.Called(ctx, ruleID, triggerEventID)
        return args.Bool(0), args.Error(1)
}</span>

// GetLogsForAccount mocks the GetLogsForAccount method.
func (m *MockStore) GetLogsForAccount(
        ctx context.Context,
        accountID uuid.UUID,
        limit int,
) ([]domain.AutomationLog, error) <span class="cov0" title="0">{
        args := m.Called(ctx, accountID, limit)
        return args.Get(0).([]domain.AutomationLog), args.Error(1)
}</span>

// GetValidTokenForAccount mocks the GetValidTokenForAccount method
func (m *MockStore) GetValidTokenForAccount(ctx context.Context, accountID uuid.UUID) (*oauth2.Token, error) <span class="cov0" title="0">{
        args := m.Called(ctx, accountID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*oauth2.Token), args.Error(1)</span>
}

// UpdateConnectedAccountToken mocks the UpdateConnectedAccountToken method
func (m *MockStore) UpdateConnectedAccountToken(ctx context.Context, params UpdateConnectedAccountTokenParams) error <span class="cov0" title="0">{
        args := m.Called(ctx, params)
        return args.Error(0)
}</span>

// CreateGmailAutomationRule mocks the CreateGmailAutomationRule method.
func (m *MockStore) CreateGmailAutomationRule(
        ctx context.Context,
        arg CreateGmailAutomationRuleParams,
) (domain.GmailAutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Get(0).(domain.GmailAutomationRule), args.Error(1)
}</span>

// GetGmailRulesForAccount mocks the GetGmailRulesForAccount method.
func (m *MockStore) GetGmailRulesForAccount(
        ctx context.Context,
        accountID uuid.UUID,
) ([]domain.GmailAutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, accountID)
        return args.Get(0).([]domain.GmailAutomationRule), args.Error(1)
}</span>

// UpdateGmailRule mocks the UpdateGmailRule method.
func (m *MockStore) UpdateGmailRule(
        ctx context.Context,
        arg UpdateGmailRuleParams,
) (domain.GmailAutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Get(0).(domain.GmailAutomationRule), args.Error(1)
}</span>

// DeleteGmailRule mocks the DeleteGmailRule method
func (m *MockStore) DeleteGmailRule(ctx context.Context, ruleID uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, ruleID)
        return args.Error(0)
}</span>

// ToggleGmailRuleStatus mocks the ToggleGmailRuleStatus method
func (m *MockStore) ToggleGmailRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.GmailAutomationRule, error) <span class="cov0" title="0">{
        args := m.Called(ctx, ruleID)
        return args.Get(0).(domain.GmailAutomationRule), args.Error(1)
}</span>

// StoreGmailMessage mocks the StoreGmailMessage method
func (m *MockStore) StoreGmailMessage(ctx context.Context, arg StoreGmailMessageParams) error <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Error(0)
}</span>

// StoreGmailThread mocks the StoreGmailThread method
func (m *MockStore) StoreGmailThread(ctx context.Context, arg StoreGmailThreadParams) error <span class="cov0" title="0">{
        args := m.Called(ctx, arg)
        return args.Error(0)
}</span>

// UpdateGmailMessageStatus mocks the UpdateGmailMessageStatus method
func (m *MockStore) UpdateGmailMessageStatus(
        ctx context.Context,
        accountID uuid.UUID,
        messageID string,
        status domain.GmailMessageStatus,
) error <span class="cov0" title="0">{
        args := m.Called(ctx, accountID, messageID, status)
        return args.Error(0)
}</span>

// GetGmailMessagesForAccount mocks the GetGmailMessagesForAccount method.
func (m *MockStore) GetGmailMessagesForAccount(
        ctx context.Context,
        accountID uuid.UUID,
        limit int,
) ([]domain.GmailMessage, error) <span class="cov0" title="0">{
        args := m.Called(ctx, accountID, limit)
        return args.Get(0).([]domain.GmailMessage), args.Error(1)
}</span>

// UpdateGmailSyncState mocks the UpdateGmailSyncState method
func (m *MockStore) UpdateGmailSyncState(
        ctx context.Context,
        accountID uuid.UUID,
        historyID string,
        lastSync time.Time,
) error <span class="cov0" title="0">{
        args := m.Called(ctx, accountID, historyID, lastSync)
        return args.Error(0)
}</span>

// GetGmailSyncState mocks the GetGmailSyncState method.
func (m *MockStore) GetGmailSyncState(
        ctx context.Context,
        accountID uuid.UUID,
) (historyID *string, lastSync *time.Time, err error) <span class="cov0" title="0">{
        args := m.Called(ctx, accountID)
        return args.Get(0).(*string), args.Get(1).(*time.Time), args.Error(2)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package rule

import (
        "context"
        "encoding/json"
        "errors"

        "agenda-automator-api/internal/database"
        "agenda-automator-api/internal/domain"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
)

// RuleStorer defines the interface for rule store operations
type RuleStorer interface {
        CreateAutomationRule(ctx context.Context, arg CreateAutomationRuleParams) (domain.AutomationRule, error)
        GetRuleByID(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error)
        GetRulesForAccount(ctx context.Context, accountID uuid.UUID) ([]domain.AutomationRule, error)
        UpdateRule(ctx context.Context, arg UpdateRuleParams) (domain.AutomationRule, error)
        ToggleRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error)
        VerifyRuleOwnership(ctx context.Context, ruleID uuid.UUID, userID uuid.UUID) error
        DeleteRule(ctx context.Context, ruleID uuid.UUID) error
}

// CreateAutomationRuleParams contains parameters for creating automation rules.
type CreateAutomationRuleParams struct {
        ConnectedAccountID uuid.UUID
        Name               string
        TriggerConditions  json.RawMessage // []byte
        ActionParams       json.RawMessage // []byte
}

// UpdateRuleParams definieert de parameters voor het bijwerken van een regel.
type UpdateRuleParams struct {
        RuleID            uuid.UUID
        Name              string
        TriggerConditions json.RawMessage
        ActionParams      json.RawMessage
}

// RuleStore handles rule-related database operations
type RuleStore struct {
        db database.Querier
}

// NewRuleStore creates a new RuleStore
func NewRuleStore(db database.Querier) RuleStorer <span class="cov8" title="1">{
        return &amp;RuleStore{db: db}
}</span>

// scanRule scans a database row into an AutomationRule
func scanRule(row pgx.Row) (domain.AutomationRule, error) <span class="cov8" title="1">{
        var rule domain.AutomationRule
        err := row.Scan(
                &amp;rule.ID,
                &amp;rule.ConnectedAccountID,
                &amp;rule.Name,
                &amp;rule.IsActive,
                &amp;rule.TriggerConditions,
                &amp;rule.ActionParams,
                &amp;rule.CreatedAt,
                &amp;rule.UpdatedAt,
        )
        return rule, err
}</span>

// CreateAutomationRule creates a new automation rule.
func (s *RuleStore) CreateAutomationRule(
        ctx context.Context,
        arg CreateAutomationRuleParams,
) (domain.AutomationRule, error) <span class="cov8" title="1">{
        query := `
    INSERT INTO automation_rules (
        connected_account_id, name, trigger_conditions, action_params
    ) VALUES (
        $1, $2, $3, $4
    )
    RETURNING id, connected_account_id, name, is_active, trigger_conditions, action_params, created_at, updated_at;
    `

        row := s.db.QueryRow(ctx, query,
                arg.ConnectedAccountID,
                arg.Name,
                arg.TriggerConditions,
                arg.ActionParams,
        )

        return scanRule(row)
}</span>

// GetRuleByID ...
func (s *RuleStore) GetRuleByID(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error) <span class="cov8" title="1">{
        query := `
            SELECT id, connected_account_id, name, is_active,
                   trigger_conditions, action_params, created_at, updated_at
            FROM automation_rules
            WHERE id = $1
            `
        row := s.db.QueryRow(ctx, query, ruleID)

        var rule domain.AutomationRule
        err := row.Scan(
                &amp;rule.ID,
                &amp;rule.ConnectedAccountID,
                &amp;rule.Name,
                &amp;rule.IsActive,
                &amp;rule.TriggerConditions,
                &amp;rule.ActionParams,
                &amp;rule.CreatedAt,
                &amp;rule.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return domain.AutomationRule{}, errors.New("rule not found")
                }</span>
                <span class="cov0" title="0">return domain.AutomationRule{}, err</span>
        }

        <span class="cov8" title="1">return rule, nil</span>
}

// GetRulesForAccount ...
func (s *RuleStore) GetRulesForAccount(ctx context.Context, accountID uuid.UUID) ([]domain.AutomationRule, error) <span class="cov8" title="1">{
        query := `
    SELECT id, connected_account_id, name, is_active,
           trigger_conditions, action_params, created_at, updated_at
    FROM automation_rules
    WHERE connected_account_id = $1
    ORDER BY created_at DESC;
    `

        rows, err := s.db.Query(ctx, query, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var rules []domain.AutomationRule
        for rows.Next() </span><span class="cov8" title="1">{
                var rule domain.AutomationRule
                err := rows.Scan(
                        &amp;rule.ID,
                        &amp;rule.ConnectedAccountID,
                        &amp;rule.Name,
                        &amp;rule.IsActive,
                        &amp;rule.TriggerConditions,
                        &amp;rule.ActionParams,
                        &amp;rule.CreatedAt,
                        &amp;rule.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">rules = append(rules, rule)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return rules, nil</span>
}

// UpdateRule werkt een bestaande regel bij.
func (s *RuleStore) UpdateRule(ctx context.Context, arg UpdateRuleParams) (domain.AutomationRule, error) <span class="cov8" title="1">{
        query := `
    UPDATE automation_rules
    SET name = $1, trigger_conditions = $2, action_params = $3, updated_at = now()
    WHERE id = $4
    RETURNING id, connected_account_id, name, is_active, trigger_conditions, action_params, created_at, updated_at;
    `
        row := s.db.QueryRow(ctx, query,
                arg.Name,
                arg.TriggerConditions,
                arg.ActionParams,
                arg.RuleID,
        )

        return scanRule(row)
}</span>

// ToggleRuleStatus zet de 'is_active' boolean van een regel om.
func (s *RuleStore) ToggleRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error) <span class="cov8" title="1">{
        query := `
    UPDATE automation_rules
    SET is_active = NOT is_active, updated_at = now()
    WHERE id = $1
    RETURNING id, connected_account_id, name, is_active, trigger_conditions, action_params, created_at, updated_at;
    `
        row := s.db.QueryRow(ctx, query, ruleID)

        var rule domain.AutomationRule
        err := row.Scan(
                &amp;rule.ID,
                &amp;rule.ConnectedAccountID,
                &amp;rule.Name,
                &amp;rule.IsActive,
                &amp;rule.TriggerConditions,
                &amp;rule.ActionParams,
                &amp;rule.CreatedAt,
                &amp;rule.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return domain.AutomationRule{}, err
        }</span>

        <span class="cov8" title="1">return rule, nil</span>
}

// VerifyRuleOwnership controleert of een gebruiker de eigenaar is van de regel (via het account).
func (s *RuleStore) VerifyRuleOwnership(ctx context.Context, ruleID uuid.UUID, userID uuid.UUID) error <span class="cov8" title="1">{
        query := `
           SELECT 1
           FROM automation_rules r
           JOIN connected_accounts ca ON r.connected_account_id = ca.id
           WHERE r.id = $1 AND ca.user_id = $2
           LIMIT 1;
           `
        var exists int
        err := s.db.QueryRow(ctx, query, ruleID, userID).Scan(&amp;exists)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return errors.New("forbidden: rule not found or does not belong to user")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// DeleteRule verwijdert een specifieke regel uit de database.
func (s *RuleStore) DeleteRule(ctx context.Context, ruleID uuid.UUID) error <span class="cov8" title="1">{
        query := `
           DELETE FROM automation_rules
           WHERE id = $1;
           `

        cmdTag, err := s.db.Exec(ctx, query, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if cmdTag.RowsAffected() == 0 </span><span class="cov8" title="1">{
                return errors.New("no rule found with ID " + ruleID.String() + " to delete")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package store

import (
        "context"
        "time"

        "agenda-automator-api/internal/database"
        "agenda-automator-api/internal/domain"
        "agenda-automator-api/internal/store/account"
        "agenda-automator-api/internal/store/gmail"
        "agenda-automator-api/internal/store/log"
        "agenda-automator-api/internal/store/rule"
        "agenda-automator-api/internal/store/user"

        "github.com/google/uuid"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
)

// Re-export parameter structs for backward compatibility
type (
        UpsertConnectedAccountParams      = account.UpsertConnectedAccountParams
        UpdateAccountTokensParams         = account.UpdateAccountTokensParams
        UpdateConnectedAccountTokenParams = account.UpdateConnectedAccountTokenParams
        CreateAutomationRuleParams        = rule.CreateAutomationRuleParams
        UpdateRuleParams                  = rule.UpdateRuleParams
        CreateLogParams                   = log.CreateLogParams
        CreateGmailAutomationRuleParams   = gmail.CreateGmailAutomationRuleParams
        UpdateGmailRuleParams             = gmail.UpdateGmailRuleParams
        StoreGmailMessageParams           = gmail.StoreGmailMessageParams
        StoreGmailThreadParams            = gmail.StoreGmailThreadParams
)

// ErrTokenRevoked re-export error for backward compatibility
var ErrTokenRevoked = account.ErrTokenRevoked

// Storer is de interface voor al onze database-interactions.
type Storer interface {
        CreateUser(ctx context.Context, email, name string) (domain.User, error)
        GetUserByID(ctx context.Context, userID uuid.UUID) (domain.User, error)
        DeleteUser(ctx context.Context, userID uuid.UUID) error

        UpsertConnectedAccount(ctx context.Context, arg UpsertConnectedAccountParams) (domain.ConnectedAccount, error)
        GetConnectedAccountByID(ctx context.Context, id uuid.UUID) (domain.ConnectedAccount, error)
        GetActiveAccounts(ctx context.Context) ([]domain.ConnectedAccount, error)
        GetAccountsForUser(ctx context.Context, userID uuid.UUID) ([]domain.ConnectedAccount, error)
        UpdateAccountTokens(ctx context.Context, arg UpdateAccountTokensParams) error
        UpdateAccountLastChecked(ctx context.Context, id uuid.UUID) error
        UpdateAccountStatus(ctx context.Context, id uuid.UUID, status domain.AccountStatus) error
        DeleteConnectedAccount(ctx context.Context, accountID uuid.UUID) error
        VerifyAccountOwnership(ctx context.Context, accountID uuid.UUID, userID uuid.UUID) error

        CreateAutomationRule(ctx context.Context, arg CreateAutomationRuleParams) (domain.AutomationRule, error)
        GetRuleByID(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error)
        GetRulesForAccount(ctx context.Context, accountID uuid.UUID) ([]domain.AutomationRule, error)
        UpdateRule(ctx context.Context, arg UpdateRuleParams) (domain.AutomationRule, error)
        ToggleRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error)
        DeleteRule(ctx context.Context, ruleID uuid.UUID) error
        VerifyRuleOwnership(ctx context.Context, ruleID uuid.UUID, userID uuid.UUID) error

        CreateAutomationLog(ctx context.Context, arg CreateLogParams) error
        HasLogForTrigger(ctx context.Context, ruleID uuid.UUID, triggerEventID string) (bool, error)
        GetLogsForAccount(ctx context.Context, accountID uuid.UUID, limit int) ([]domain.AutomationLog, error)

        // Gecentraliseerde Token Logica
        GetValidTokenForAccount(ctx context.Context, accountID uuid.UUID) (*oauth2.Token, error)

        // UpdateConnectedAccountToken update access/refresh token
        UpdateConnectedAccountToken(ctx context.Context, params UpdateConnectedAccountTokenParams) error

        // Gmail-specific methods
        CreateGmailAutomationRule(ctx context.Context, arg CreateGmailAutomationRuleParams) (domain.GmailAutomationRule, error)
        GetGmailRulesForAccount(ctx context.Context, accountID uuid.UUID) ([]domain.GmailAutomationRule, error)
        UpdateGmailRule(ctx context.Context, arg UpdateGmailRuleParams) (domain.GmailAutomationRule, error)
        DeleteGmailRule(ctx context.Context, ruleID uuid.UUID) error
        ToggleGmailRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.GmailAutomationRule, error)

        // Gmail message storage
        StoreGmailMessage(ctx context.Context, arg StoreGmailMessageParams) error
        StoreGmailThread(ctx context.Context, arg StoreGmailThreadParams) error
        UpdateGmailMessageStatus(
                ctx context.Context,
                accountID uuid.UUID,
                messageID string,
                status domain.GmailMessageStatus,
        ) error
        GetGmailMessagesForAccount(ctx context.Context, accountID uuid.UUID, limit int) ([]domain.GmailMessage, error)

        // Gmail sync tracking
        UpdateGmailSyncState(ctx context.Context, accountID uuid.UUID, historyID string, lastSync time.Time) error
        GetGmailSyncState(ctx context.Context, accountID uuid.UUID) (historyID *string, lastSync *time.Time, err error)
}

// DBStore implementeert de Storer interface.
type DBStore struct {
        userStore    user.UserStorer
        accountStore account.AccountStorer
        ruleStore    rule.RuleStorer
        logStore     log.LogStorer     // &lt;-- GEWIJZIGD (naar interface)
        gmailStore   gmail.GmailStorer // &lt;-- GEWIJZIGD (naar interface)
}

// NewStore maakt een nieuwe DBStore
func NewStore(db database.Querier, oauthCfg *oauth2.Config, logger *zap.Logger) Storer <span class="cov8" title="1">{
        return &amp;DBStore{
                userStore:    user.NewUserStore(db),
                accountStore: account.NewAccountStore(db, oauthCfg, logger),
                ruleStore:    rule.NewRuleStore(db),
                logStore:     log.NewLogStore(db),
                gmailStore:   gmail.NewGmailStore(db, logger),
        }
}</span>

// --- USER FUNCTIES ---

// CreateUser maakt een nieuwe gebruiker aan in de database
func (s *DBStore) CreateUser(ctx context.Context, email, name string) (domain.User, error) <span class="cov8" title="1">{
        return s.userStore.CreateUser(ctx, email, name)
}</span>

// GetUserByID haalt een gebruiker op basis van ID.
func (s *DBStore) GetUserByID(ctx context.Context, userID uuid.UUID) (domain.User, error) <span class="cov8" title="1">{
        return s.userStore.GetUserByID(ctx, userID)
}</span>

// DeleteUser verwijdert een gebruiker en al zijn data (via ON DELETE CASCADE).
func (s *DBStore) DeleteUser(ctx context.Context, userID uuid.UUID) error <span class="cov8" title="1">{
        return s.userStore.DeleteUser(ctx, userID)
}</span>

// --- ACCOUNT FUNCTIES ---

// UpsertConnectedAccount versleutelt de tokens en slaat het account op (upsert).
func (s *DBStore) UpsertConnectedAccount(
        ctx context.Context,
        arg UpsertConnectedAccountParams,
) (domain.ConnectedAccount, error) <span class="cov8" title="1">{
        return s.accountStore.UpsertConnectedAccount(ctx, arg)
}</span>

// GetConnectedAccountByID ...
func (s *DBStore) GetConnectedAccountByID(ctx context.Context, id uuid.UUID) (domain.ConnectedAccount, error) <span class="cov8" title="1">{
        return s.accountStore.GetConnectedAccountByID(ctx, id)
}</span>

// UpdateAccountTokens ...
func (s *DBStore) UpdateAccountTokens(ctx context.Context, arg UpdateAccountTokensParams) error <span class="cov8" title="1">{
        return s.accountStore.UpdateAccountTokens(ctx, arg)
}</span>

// UpdateAccountLastChecked updates the last checked time for an account.
func (s *DBStore) UpdateAccountLastChecked(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        return s.accountStore.UpdateAccountLastChecked(ctx, id)
}</span>

// GetActiveAccounts haalt alle accounts op die de worker moet controleren
func (s *DBStore) GetActiveAccounts(ctx context.Context) ([]domain.ConnectedAccount, error) <span class="cov8" title="1">{
        return s.accountStore.GetActiveAccounts(ctx)
}</span>

// GetAccountsForUser haalt alle accounts op die eigendom zijn van een specifieke gebruiker
func (s *DBStore) GetAccountsForUser(ctx context.Context, userID uuid.UUID) ([]domain.ConnectedAccount, error) <span class="cov8" title="1">{
        return s.accountStore.GetAccountsForUser(ctx, userID)
}</span>

// VerifyAccountOwnership controleert of een gebruiker eigenaar is van een account
func (s *DBStore) VerifyAccountOwnership(ctx context.Context, accountID uuid.UUID, userID uuid.UUID) error <span class="cov8" title="1">{
        return s.accountStore.VerifyAccountOwnership(ctx, accountID, userID)
}</span>

// DeleteConnectedAccount verwijdert een specifiek account en diens data.
func (s *DBStore) DeleteConnectedAccount(ctx context.Context, accountID uuid.UUID) error <span class="cov8" title="1">{
        return s.accountStore.DeleteConnectedAccount(ctx, accountID)
}</span>

// --- RULE FUNCTIES ---

// CreateAutomationRule creates a new automation rule.
func (s *DBStore) CreateAutomationRule(
        ctx context.Context,
        arg CreateAutomationRuleParams,
) (domain.AutomationRule, error) <span class="cov8" title="1">{
        return s.ruleStore.CreateAutomationRule(ctx, arg)
}</span>

// GetRuleByID ...
func (s *DBStore) GetRuleByID(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error) <span class="cov8" title="1">{
        return s.ruleStore.GetRuleByID(ctx, ruleID)
}</span>

// GetRulesForAccount ...
func (s *DBStore) GetRulesForAccount(ctx context.Context, accountID uuid.UUID) ([]domain.AutomationRule, error) <span class="cov8" title="1">{
        return s.ruleStore.GetRulesForAccount(ctx, accountID)
}</span>

// UpdateRule werkt een bestaande regel bij.
func (s *DBStore) UpdateRule(ctx context.Context, arg UpdateRuleParams) (domain.AutomationRule, error) <span class="cov8" title="1">{
        return s.ruleStore.UpdateRule(ctx, arg)
}</span>

// ToggleRuleStatus zet de 'is_active' boolean van een regel om.
func (s *DBStore) ToggleRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.AutomationRule, error) <span class="cov8" title="1">{
        return s.ruleStore.ToggleRuleStatus(ctx, ruleID)
}</span>

// VerifyRuleOwnership controleert of een gebruiker de eigenaar is van de regel (via het account).
func (s *DBStore) VerifyRuleOwnership(ctx context.Context, ruleID uuid.UUID, userID uuid.UUID) error <span class="cov8" title="1">{
        return s.ruleStore.VerifyRuleOwnership(ctx, ruleID, userID)
}</span>

// DeleteRule verwijdert een specifieke regel uit de database.
func (s *DBStore) DeleteRule(ctx context.Context, ruleID uuid.UUID) error <span class="cov8" title="1">{
        return s.ruleStore.DeleteRule(ctx, ruleID)
}</span>

// --- LOG FUNCTIES ---

// UpdateAccountStatus updates the status of an account.
func (s *DBStore) UpdateAccountStatus(ctx context.Context, id uuid.UUID, status domain.AccountStatus) error <span class="cov8" title="1">{
        return s.accountStore.UpdateAccountStatus(ctx, id, status)
}</span>

// CreateAutomationLog creates a new automation log.
func (s *DBStore) CreateAutomationLog(ctx context.Context, arg CreateLogParams) error <span class="cov8" title="1">{
        return s.logStore.CreateAutomationLog(ctx, arg)
}</span>

// HasLogForTrigger checks if a log exists for a trigger event.
func (s *DBStore) HasLogForTrigger(ctx context.Context, ruleID uuid.UUID, triggerEventID string) (bool, error) <span class="cov8" title="1">{
        return s.logStore.HasLogForTrigger(ctx, ruleID, triggerEventID)
}</span>

// GetLogsForAccount haalt de meest recente logs op voor een account.
func (s *DBStore) GetLogsForAccount(
        ctx context.Context,
        accountID uuid.UUID,
        limit int,
) ([]domain.AutomationLog, error) <span class="cov8" title="1">{
        return s.logStore.GetLogsForAccount(ctx, accountID, limit)
}</span>

// --- GECENTRALISEERDE TOKEN LOGICA ---

// GetValidTokenForAccount is de centrale functie die een token ophaalt,
// en indien nodig ververst en opslaat.
func (s *DBStore) GetValidTokenForAccount(ctx context.Context, accountID uuid.UUID) (*oauth2.Token, error) <span class="cov8" title="1">{
        return s.accountStore.GetValidTokenForAccount(ctx, accountID)
}</span>

// UpdateConnectedAccountToken update access/refresh token
func (s *DBStore) UpdateConnectedAccountToken(ctx context.Context, params UpdateConnectedAccountTokenParams) error <span class="cov8" title="1">{
        return s.accountStore.UpdateConnectedAccountToken(ctx, params)
}</span>

// --- GMAIL AUTOMATION RULE METHODS ---

// CreateGmailAutomationRule creates a new Gmail automation rule.
func (s *DBStore) CreateGmailAutomationRule(
        ctx context.Context,
        arg CreateGmailAutomationRuleParams,
) (domain.GmailAutomationRule, error) <span class="cov8" title="1">{
        return s.gmailStore.CreateGmailAutomationRule(ctx, arg)
}</span>

// GetGmailRulesForAccount gets all Gmail automation rules for an account.
func (s *DBStore) GetGmailRulesForAccount(
        ctx context.Context,
        accountID uuid.UUID,
) ([]domain.GmailAutomationRule, error) <span class="cov8" title="1">{
        return s.gmailStore.GetGmailRulesForAccount(ctx, accountID)
}</span>

// UpdateGmailRule updates an existing Gmail automation rule.
func (s *DBStore) UpdateGmailRule(
        ctx context.Context,
        arg UpdateGmailRuleParams,
) (domain.GmailAutomationRule, error) <span class="cov8" title="1">{
        return s.gmailStore.UpdateGmailRule(ctx, arg)
}</span>

// DeleteGmailRule deletes a Gmail automation rule
func (s *DBStore) DeleteGmailRule(ctx context.Context, ruleID uuid.UUID) error <span class="cov8" title="1">{
        return s.gmailStore.DeleteGmailRule(ctx, ruleID)
}</span>

// ToggleGmailRuleStatus toggles the active status of a Gmail automation rule
func (s *DBStore) ToggleGmailRuleStatus(ctx context.Context, ruleID uuid.UUID) (domain.GmailAutomationRule, error) <span class="cov8" title="1">{
        return s.gmailStore.ToggleGmailRuleStatus(ctx, ruleID)
}</span>

// --- GMAIL MESSAGE STORAGE METHODS ---

// StoreGmailMessage stores or updates a Gmail message
func (s *DBStore) StoreGmailMessage(ctx context.Context, arg StoreGmailMessageParams) error <span class="cov8" title="1">{
        return s.gmailStore.StoreGmailMessage(ctx, arg)
}</span>

// StoreGmailThread stores or updates a Gmail thread
func (s *DBStore) StoreGmailThread(ctx context.Context, arg StoreGmailThreadParams) error <span class="cov8" title="1">{
        return s.gmailStore.StoreGmailThread(ctx, arg)
}</span>

// UpdateGmailMessageStatus updates the status of a Gmail message.
func (s *DBStore) UpdateGmailMessageStatus(
        ctx context.Context,
        accountID uuid.UUID,
        messageID string,
        status domain.GmailMessageStatus,
) error <span class="cov8" title="1">{
        return s.gmailStore.UpdateGmailMessageStatus(ctx, accountID, messageID, status)
}</span>

// GetGmailMessagesForAccount gets recent Gmail messages for an account.
func (s *DBStore) GetGmailMessagesForAccount(
        ctx context.Context,
        accountID uuid.UUID,
        limit int,
) ([]domain.GmailMessage, error) <span class="cov8" title="1">{
        return s.gmailStore.GetGmailMessagesForAccount(ctx, accountID, limit)
}</span>

// --- GMAIL SYNC STATE METHODS ---

// UpdateGmailSyncState updates the Gmail sync state for an account.
func (s *DBStore) UpdateGmailSyncState(
        ctx context.Context,
        accountID uuid.UUID,
        historyID string,
        lastSync time.Time,
) error <span class="cov8" title="1">{
        return s.gmailStore.UpdateGmailSyncState(ctx, accountID, historyID, lastSync)
}</span>

// GetGmailSyncState gets the Gmail sync state for an account.
func (s *DBStore) GetGmailSyncState(
        ctx context.Context,
        accountID uuid.UUID,
) (historyID *string, lastSync *time.Time, err error) <span class="cov8" title="1">{
        return s.gmailStore.GetGmailSyncState(ctx, accountID)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package user

import (
        "context"
        "errors"

        "agenda-automator-api/internal/database"
        "agenda-automator-api/internal/domain"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
)

// UserStorer defines the interface for user store operations
type UserStorer interface {
        CreateUser(ctx context.Context, email, name string) (domain.User, error)
        GetUserByID(ctx context.Context, userID uuid.UUID) (domain.User, error)
        DeleteUser(ctx context.Context, userID uuid.UUID) error
}

// UserStore handles user-related database operations
type UserStore struct {
        db database.Querier
}

// NewUserStore creates a new UserStore
func NewUserStore(db database.Querier) UserStorer <span class="cov8" title="1">{
        return &amp;UserStore{db: db}
}</span>

// CreateUser maakt een nieuwe gebruiker aan in de database
func (s *UserStore) CreateUser(ctx context.Context, email, name string) (domain.User, error) <span class="cov8" title="1">{
        query := `
    INSERT INTO users (email, name)
    VALUES ($1, $2)
    ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name
    RETURNING id, email, name, created_at, updated_at;
    `

        row := s.db.QueryRow(ctx, query, email, name)

        var u domain.User
        err := row.Scan(
                &amp;u.ID,
                &amp;u.Email,
                &amp;u.Name,
                &amp;u.CreatedAt,
                &amp;u.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return domain.User{}, err
        }</span>

        <span class="cov8" title="1">return u, nil</span>
}

// GetUserByID haalt een gebruiker op basis van ID.
func (s *UserStore) GetUserByID(ctx context.Context, userID uuid.UUID) (domain.User, error) <span class="cov8" title="1">{
        query := `SELECT id, email, name, created_at, updated_at FROM users WHERE id = $1`
        row := s.db.QueryRow(ctx, query, userID)

        var u domain.User
        err := row.Scan(
                &amp;u.ID,
                &amp;u.Email,
                &amp;u.Name,
                &amp;u.CreatedAt,
                &amp;u.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return domain.User{}, errors.New("user not found")
                }</span>
                <span class="cov0" title="0">return domain.User{}, err</span>
        }

        <span class="cov8" title="1">return u, nil</span>
}

// DeleteUser verwijdert een gebruiker en al zijn data (via ON DELETE CASCADE).
func (s *UserStore) DeleteUser(ctx context.Context, userID uuid.UUID) error <span class="cov8" title="1">{
        query := `DELETE FROM users WHERE id = $1`
        cmdTag, err := s.db.Exec(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if cmdTag.RowsAffected() == 0 </span><span class="cov8" title="1">{
                return errors.New("no user found with ID " + userID.String() + " to delete")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package calendar

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"

        "golang.org/x/oauth2"
        "google.golang.org/api/calendar/v3"
        "google.golang.org/api/option"

        "agenda-automator-api/internal/domain"
        "agenda-automator-api/internal/store"
)

// CalendarProcessor handles calendar event processing
type CalendarProcessor struct {
        store      store.Storer
        newService func(ctx context.Context, client *http.Client) (*calendar.Service, error)
}

// NewCalendarProcessor creates a new calendar processor
func NewCalendarProcessor(s store.Storer) *CalendarProcessor <span class="cov8" title="1">{
        return &amp;CalendarProcessor{
                store: s,
                newService: func(ctx context.Context, client *http.Client) (*calendar.Service, error) </span><span class="cov0" title="0">{
                        return calendar.NewService(ctx, option.WithHTTPClient(client))
                }</span>,
        }
}

// ProcessEvents processes calendar events for automation rules.
func (cp *CalendarProcessor) ProcessEvents(
        ctx context.Context,
        acc *domain.ConnectedAccount,
        token *oauth2.Token,
) error <span class="cov8" title="1">{
        rules, err := cp.store.GetRulesForAccount(ctx, acc.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not fetch automation rules: %w", err)
        }</span>

        <span class="cov8" title="1">if len(rules) == 0 </span><span class="cov0" title="0">{
                log.Printf("[Calendar] No rules found for %s. Skipping.", acc.Email)
                return nil
        }</span>

        // Create calendar service
        <span class="cov8" title="1">client := oauth2.NewClient(ctx, oauth2.StaticTokenSource(token))
        srv, err := cp.newService(ctx, client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create calendar service: %w", err)
        }</span>

        // Fetch all events
        <span class="cov8" title="1">tMin := time.Date(1970, 1, 1, 0, 0, 0, 0, time.UTC).Format(time.RFC3339)
        tMax := time.Date(2100, 1, 1, 0, 0, 0, 0, time.UTC).Format(time.RFC3339)

        log.Printf("[Calendar] Fetching all calendar events for %s (unlimited)", acc.Email)

        events, err := srv.Events.List("primary").
                TimeMin(tMin).
                TimeMax(tMax).
                SingleEvents(true).
                OrderBy("startTime").
                MaxResults(2500).
                Do()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not fetch calendar events: %w", err)
        }</span>

        <span class="cov8" title="1">if len(events.Items) == 0 </span><span class="cov0" title="0">{
                log.Printf("[Calendar] No upcoming events found for %s. Skipping.", acc.Email)
                return nil
        }</span>

        <span class="cov8" title="1">log.Printf("[Calendar] Checking %d events against %d rules for %s...", len(events.Items), len(rules), acc.Email)

        for _, event := range events.Items </span><span class="cov8" title="1">{
                // Skip own created events
                if strings.HasPrefix(event.Description, "Automatische reminder voor:") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                        if !rule.IsActive </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">var trigger domain.TriggerConditions
                        if err = json.Unmarshal(rule.TriggerConditions, &amp;trigger); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Calendar] ERROR unmarshaling trigger for rule %s: %v", rule.ID, err)
                                continue</span>
                        }

                        // Check triggers
                        <span class="cov8" title="1">summaryMatch := false
                        if trigger.SummaryEquals != "" &amp;&amp; event.Summary == trigger.SummaryEquals </span><span class="cov8" title="1">{
                                summaryMatch = true
                        }</span>
                        <span class="cov8" title="1">if !summaryMatch &amp;&amp; len(trigger.SummaryContains) &gt; 0 </span><span class="cov0" title="0">{
                                for _, contain := range trigger.SummaryContains </span><span class="cov0" title="0">{
                                        if strings.Contains(event.Summary, contain) </span><span class="cov0" title="0">{
                                                summaryMatch = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if !summaryMatch </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">locationMatch := false
                        if len(trigger.LocationContains) == 0 </span><span class="cov8" title="1">{
                                locationMatch = true
                        }</span> else<span class="cov0" title="0"> {
                                eventLocationLower := strings.ToLower(event.Location)
                                for _, loc := range trigger.LocationContains </span><span class="cov0" title="0">{
                                        if strings.Contains(eventLocationLower, strings.ToLower(loc)) </span><span class="cov0" title="0">{
                                                locationMatch = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if !locationMatch </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check logs
                        <span class="cov8" title="1">hasLogged, err := cp.store.HasLogForTrigger(ctx, rule.ID, event.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Calendar] ERROR checking logs for event %s / rule %s: %v", event.Id, rule.ID, err)
                        }</span>
                        <span class="cov8" title="1">if hasLogged </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">log.Printf("[Calendar] MATCH: Event '%s' (ID: %s) matches rule '%s'.", event.Summary, event.Id, rule.Name)

                        var action domain.ActionParams
                        if err = json.Unmarshal(rule.ActionParams, &amp;action); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Calendar] ERROR unmarshaling action for rule %s: %v", rule.ID, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">if action.NewEventTitle == "" </span><span class="cov0" title="0">{
                                log.Printf("[Calendar] ERROR: Rule %s heeft geen 'new_event_title'.", rule.ID)
                                continue</span>
                        }

                        <span class="cov8" title="1">startTime, err := time.Parse(time.RFC3339, event.Start.DateTime)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Calendar] ERROR parsing start time: %v", err)
                                continue</span>
                        }

                        <span class="cov8" title="1">offset := action.OffsetMinutes
                        if offset == 0 </span><span class="cov0" title="0">{
                                offset = -60
                        }</span>
                        <span class="cov8" title="1">reminderTime := startTime.Add(time.Duration(offset) * time.Minute)

                        durMin := action.DurationMin
                        if durMin == 0 </span><span class="cov0" title="0">{
                                durMin = 5
                        }</span>
                        <span class="cov8" title="1">endTime := reminderTime.Add(time.Duration(durMin) * time.Minute)

                        title := action.NewEventTitle

                        // Check for duplicates
                        if cp.eventExists(srv, reminderTime, endTime, title) </span><span class="cov0" title="0">{
                                log.Printf("[Calendar] SKIP: Reminder event '%s' at %s already exists.", title, reminderTime)

                                triggerDetailsJSON, _ := json.Marshal(domain.TriggerLogDetails{
                                        GoogleEventID:  event.Id,
                                        TriggerSummary: event.Summary,
                                        TriggerTime:    startTime,
                                })
                                actionDetailsJSON, _ := json.Marshal(domain.ActionLogDetails{
                                        CreatedEventID:      "unknown-pre-existing",
                                        CreatedEventSummary: title,
                                        ReminderTime:        reminderTime,
                                })
                                logParams := store.CreateLogParams{
                                        ConnectedAccountID: acc.ID,
                                        RuleID:             &amp;rule.ID,
                                        Status:             domain.LogSkipped,
                                        TriggerDetails:     triggerDetailsJSON,
                                        ActionDetails:      actionDetailsJSON,
                                }
                                if err = cp.store.CreateAutomationLog(ctx, logParams); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("[Calendar] ERROR saving skip log for rule %s: %v", rule.ID, err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // Create event
                        <span class="cov8" title="1">newEvent := &amp;calendar.Event{
                                Summary: title,
                                Start: &amp;calendar.EventDateTime{
                                        DateTime: reminderTime.Format(time.RFC3339),
                                        TimeZone: event.Start.TimeZone,
                                },
                                End: &amp;calendar.EventDateTime{
                                        DateTime: endTime.Format(time.RFC3339),
                                        TimeZone: event.End.TimeZone,
                                },
                                Description: fmt.Sprintf("Automatische reminder voor: %s\nGemaakt door regel: %s", event.Summary, rule.Name),
                        }

                        createdEvent, err := srv.Events.Insert("primary", newEvent).Do()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Calendar] ERROR creating reminder event: %v", err)

                                triggerDetailsJSON, _ := json.Marshal(domain.TriggerLogDetails{
                                        GoogleEventID:  event.Id,
                                        TriggerSummary: event.Summary,
                                        TriggerTime:    startTime,
                                })
                                logParams := store.CreateLogParams{
                                        ConnectedAccountID: acc.ID,
                                        RuleID:             &amp;rule.ID,
                                        Status:             domain.LogFailure,
                                        TriggerDetails:     triggerDetailsJSON,
                                        ErrorMessage:       err.Error(),
                                }
                                if err = cp.store.CreateAutomationLog(ctx, logParams); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("[Calendar] ERROR saving failure log for rule %s: %v", rule.ID, err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // Log success
                        <span class="cov8" title="1">triggerDetailsJSON, _ := json.Marshal(domain.TriggerLogDetails{
                                GoogleEventID:  event.Id,
                                TriggerSummary: event.Summary,
                                TriggerTime:    startTime,
                        })
                        actionDetailsJSON, _ := json.Marshal(domain.ActionLogDetails{
                                CreatedEventID:      createdEvent.Id,
                                CreatedEventSummary: createdEvent.Summary,
                                ReminderTime:        reminderTime,
                        })

                        logParams := store.CreateLogParams{
                                ConnectedAccountID: acc.ID,
                                RuleID:             &amp;rule.ID,
                                Status:             domain.LogSuccess,
                                TriggerDetails:     triggerDetailsJSON,
                                ActionDetails:      actionDetailsJSON,
                        }
                        if err = cp.store.CreateAutomationLog(ctx, logParams); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Calendar] ERROR saving success log for rule %s: %v", rule.ID, err)
                        }</span>

                        <span class="cov8" title="1">log.Printf(
                                "[Calendar] SUCCESS: Created reminder '%s' (ID: %s) for event '%s' (ID: %s)",
                                createdEvent.Summary,
                                createdEvent.Id,
                                event.Summary,
                                event.Id,
                        )</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// eventExists checks if an event with the same title exists in the given time window
func (cp *CalendarProcessor) eventExists(srv *calendar.Service, start, end time.Time, title string) bool <span class="cov8" title="1">{
        timeMin := start.Add(-1 * time.Minute).Format(time.RFC3339)
        timeMax := end.Add(1 * time.Minute).Format(time.RFC3339)

        events, err := srv.Events.List("primary").
                TimeMin(timeMin).
                TimeMax(timeMax).
                SingleEvents(true).
                Do()

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[Calendar] ERROR checking for existing event: %v", err)
                return false
        }</span>

        <span class="cov8" title="1">for _, item := range events.Items </span><span class="cov0" title="0">{
                if item.Summary == title </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package gmail handles Gmail-related background tasks.
package gmail

import (
        "context"
        "encoding/json"
        "log"

        "agenda-automator-api/internal/domain"

        "google.golang.org/api/gmail/v1"
)

// Action implementations.
func (gp *GmailProcessor) executeAutoReply(
        _ context.Context,
        srv *gmail.Service,
        acc *domain.ConnectedAccount,
        message *gmail.Message,
        rule domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        var params struct {
                ReplyText string `json:"reply_text"`
        }
        if err := json.Unmarshal(rule.ActionParams, &amp;params); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">reply := &amp;gmail.Message{
                ThreadId: message.ThreadId,
                Raw:      gp.createReplyRaw(message, params.ReplyText, acc.Email),
        }

        _, err := srv.Users.Messages.Send("me", reply).Do()
        return err</span>
}

func (gp *GmailProcessor) executeAddLabel(
        _ context.Context,
        srv *gmail.Service,
        _ *domain.ConnectedAccount,
        message *gmail.Message,
        rule domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        var params struct {
                LabelName string `json:"label_name"`
        }
        if err := json.Unmarshal(rule.ActionParams, &amp;params); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">label, err := gp.getOrCreateLabel(srv, params.LabelName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">modifyRequest := &amp;gmail.ModifyMessageRequest{
                AddLabelIds: []string{label.Id},
        }

        _, err = srv.Users.Messages.Modify("me", message.Id, modifyRequest).Do()
        return err</span>
}

func (gp *GmailProcessor) executeRemoveLabel(
        _ context.Context,
        srv *gmail.Service,
        _ *domain.ConnectedAccount,
        message *gmail.Message,
        rule domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        var params struct {
                LabelName string `json:"label_name"`
        }
        if err := json.Unmarshal(rule.ActionParams, &amp;params); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">label, err := gp.getLabelByName(srv, params.LabelName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">modifyRequest := &amp;gmail.ModifyMessageRequest{
                RemoveLabelIds: []string{label.Id},
        }

        _, err = srv.Users.Messages.Modify("me", message.Id, modifyRequest).Do()
        return err</span>
}

func (gp *GmailProcessor) executeMarkRead(
        _ context.Context,
        srv *gmail.Service,
        _ *domain.ConnectedAccount,
        message *gmail.Message,
        _ domain.GmailAutomationRule,
) error <span class="cov8" title="1">{
        modifyRequest := &amp;gmail.ModifyMessageRequest{
                RemoveLabelIds: []string{"UNREAD"},
        }
        _, err := srv.Users.Messages.Modify("me", message.Id, modifyRequest).Do()
        return err
}</span>

func (gp *GmailProcessor) executeMarkUnread(
        _ context.Context,
        srv *gmail.Service,
        _ *domain.ConnectedAccount,
        message *gmail.Message,
        _ domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        modifyRequest := &amp;gmail.ModifyMessageRequest{
                AddLabelIds: []string{"UNREAD"},
        }
        _, err := srv.Users.Messages.Modify("me", message.Id, modifyRequest).Do()
        return err
}</span>

func (gp *GmailProcessor) executeArchive(
        _ context.Context,
        srv *gmail.Service,
        _ *domain.ConnectedAccount,
        message *gmail.Message,
        _ domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        modifyRequest := &amp;gmail.ModifyMessageRequest{
                RemoveLabelIds: []string{"INBOX"},
        }
        _, err := srv.Users.Messages.Modify("me", message.Id, modifyRequest).Do()
        return err
}</span>

func (gp *GmailProcessor) executeTrash(
        _ context.Context,
        srv *gmail.Service,
        _ *domain.ConnectedAccount,
        message *gmail.Message,
        _ domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        modifyRequest := &amp;gmail.ModifyMessageRequest{
                AddLabelIds: []string{"TRASH"},
        }
        _, err := srv.Users.Messages.Modify("me", message.Id, modifyRequest).Do()
        return err
}</span>

func (gp *GmailProcessor) executeStar(
        _ context.Context,
        srv *gmail.Service,
        _ *domain.ConnectedAccount,
        message *gmail.Message,
        _ domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        modifyRequest := &amp;gmail.ModifyMessageRequest{
                AddLabelIds: []string{"STARRED"},
        }
        _, err := srv.Users.Messages.Modify("me", message.Id, modifyRequest).Do()
        return err
}</span>

func (gp *GmailProcessor) executeUnstar(
        _ context.Context,
        srv *gmail.Service,
        _ *domain.ConnectedAccount,
        message *gmail.Message,
        _ domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        modifyRequest := &amp;gmail.ModifyMessageRequest{
                RemoveLabelIds: []string{"STARRED"},
        }
        _, err := srv.Users.Messages.Modify("me", message.Id, modifyRequest).Do()
        return err
}</span>

// Simplified implementations.
func (gp *GmailProcessor) executeForward(
        _ context.Context,
        _ *gmail.Service,
        _ *domain.ConnectedAccount,
        _ *gmail.Message,
        _ domain.GmailAutomationRule,
) error <span class="cov0" title="0">{
        log.Printf("[Gmail] Forward action not yet implemented")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package gmail handles Gmail-related background tasks.
package gmail

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "strconv"
        "time"

        "agenda-automator-api/internal/domain"
        "agenda-automator-api/internal/store"

        "golang.org/x/oauth2"
        "google.golang.org/api/gmail/v1"
        "google.golang.org/api/option"
)

// GmailProcessor handles Gmail message processing
type GmailProcessor struct {
        store      store.Storer
        newService func(ctx context.Context, client *http.Client) (*gmail.Service, error)
}

// NewGmailProcessor creates a new Gmail processor
func NewGmailProcessor(s store.Storer) *GmailProcessor <span class="cov8" title="1">{
        return &amp;GmailProcessor{
                store: s,
                newService: func(ctx context.Context, client *http.Client) (*gmail.Service, error) </span><span class="cov0" title="0">{
                        return gmail.NewService(ctx, option.WithHTTPClient(client))
                }</span>,
        }
}

// ProcessMessages processes Gmail messages for automation rules
func (gp *GmailProcessor) ProcessMessages(ctx context.Context, acc *domain.ConnectedAccount, token *oauth2.Token) error <span class="cov8" title="1">{
        // Create Gmail service
        client := oauth2.NewClient(ctx, oauth2.StaticTokenSource(token))
        srv, err := gp.newService(ctx, client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create Gmail service: %w", err)
        }</span>

        // Get current sync state
        <span class="cov8" title="1">historyID, lastSync, err := gp.store.GetGmailSyncState(ctx, acc.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[Gmail] Could not get Gmail sync state for %s: %v", acc.Email, err)
        }</span>

        // Fetch Gmail rules
        <span class="cov8" title="1">rules, err := gp.store.GetGmailRulesForAccount(ctx, acc.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not fetch Gmail rules: %w", err)
        }</span>

        <span class="cov8" title="1">activeRules := make([]domain.GmailAutomationRule, 0)
        for _, rule := range rules </span><span class="cov8" title="1">{
                if rule.IsActive </span><span class="cov8" title="1">{
                        activeRules = append(activeRules, rule)
                }</span>
        }

        <span class="cov8" title="1">if len(activeRules) == 0 </span><span class="cov8" title="1">{
                log.Printf("[Gmail] No active Gmail rules for %s", acc.Email)
                return nil
        }</span>

        <span class="cov8" title="1">log.Printf("[Gmail] Processing Gmail for %s with %d active rules", acc.Email, len(activeRules))

        // Use History API for incremental sync if possible
        var messagesToProcess []*gmail.Message
        if historyID != nil &amp;&amp; lastSync != nil </span><span class="cov0" title="0">{
                historyIDUint, perr := strconv.ParseUint(*historyID, 10, 64)
                if perr != nil </span><span class="cov0" title="0">{
                        log.Printf("[Gmail] Invalid history ID format for %s, falling back to full sync: %v", acc.Email, perr)
                        messagesToProcess, err = gp.fetchRecentMessages(srv, acc)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not fetch recent messages: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        historyCall := srv.Users.History.List("me").StartHistoryId(historyIDUint)
                        history, perr := historyCall.Do()
                        if perr != nil </span><span class="cov0" title="0">{
                                log.Printf("[Gmail] History API failed for %s, falling back to full sync: %v", acc.Email, err)
                                messagesToProcess, err = gp.fetchRecentMessages(srv, acc)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("could not fetch recent messages: %w", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                messagesToProcess = gp.processHistoryItems(history, srv)

                                if history.HistoryId != 0 </span><span class="cov0" title="0">{
                                        newHistoryID := fmt.Sprintf("%d", history.HistoryId)
                                        err = gp.store.UpdateGmailSyncState(ctx, acc.ID, newHistoryID, time.Now())
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("[Gmail] Failed to update Gmail sync state: %v", err)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> {
                // Full sync
                messagesToProcess, err = gp.fetchRecentMessages(srv, acc)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not fetch recent messages: %w", err)
                }</span>

                <span class="cov8" title="1">profile, perr := srv.Users.GetProfile("me").Do()
                if perr == nil &amp;&amp; profile.HistoryId != 0 </span><span class="cov8" title="1">{
                        initialHistoryID := fmt.Sprintf("%d", profile.HistoryId)
                        err = gp.store.UpdateGmailSyncState(ctx, acc.ID, initialHistoryID, time.Now())
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Gmail] Failed to store initial Gmail sync state: %v", err)
                        }</span>
                }
        }

        // Process messages
        <span class="cov8" title="1">for _, message := range messagesToProcess </span><span class="cov8" title="1">{
                err = gp.processMessageAgainstRules(ctx, srv, acc, message, activeRules)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[Gmail] Error processing message %s: %v", message.Id, err)
                }</span>
        }

        <span class="cov8" title="1">log.Printf("[Gmail] Completed Gmail processing for %s", acc.Email)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package gmail handles Gmail-related background tasks.
package gmail

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "time"

        "agenda-automator-api/internal/domain"
        "agenda-automator-api/internal/store"

        "github.com/google/uuid"
        "google.golang.org/api/gmail/v1"
)

// storeMessageInDB stores a Gmail message in the database.
func (gp *GmailProcessor) storeMessageInDB(
        ctx context.Context,
        acc *domain.ConnectedAccount,
        message *gmail.Message,
) error <span class="cov8" title="1">{
        subject := gp.getHeaderValue(message.Payload.Headers, "Subject")
        sender := gp.getHeaderValue(message.Payload.Headers, "From")
        snippet := message.Snippet

        var toRecipients, ccRecipients, bccRecipients []string
        if message.Payload != nil </span><span class="cov8" title="1">{
                toRecipients = gp.extractRecipients(message.Payload.Headers, "To")
                ccRecipients = gp.extractRecipients(message.Payload.Headers, "Cc")
                bccRecipients = gp.extractRecipients(message.Payload.Headers, "Bcc")
        }</span>

        <span class="cov8" title="1">var status domain.GmailMessageStatus
        if gp.hasLabel(message.LabelIds, "UNREAD") </span><span class="cov8" title="1">{
                status = domain.GmailUnread
        }</span> else<span class="cov0" title="0"> {
                status = domain.GmailRead
        }</span>

        <span class="cov8" title="1">isStarred := gp.hasLabel(message.LabelIds, "STARRED")
        hasAttachments := len(message.Payload.Parts) &gt; 1 ||
                (message.Payload.Body != nil &amp;&amp; message.Payload.Body.Size &gt; 0 &amp;&amp; len(message.Payload.Parts) &gt; 0)

        receivedAt := time.Unix(message.InternalDate/1000, 0)

        params := store.StoreGmailMessageParams{
                ConnectedAccountID: acc.ID,
                GmailMessageID:     message.Id,
                GmailThreadID:      message.ThreadId,
                Subject:            subject,
                Sender:             sender,
                Recipients:         toRecipients,
                CcRecipients:       ccRecipients,
                BccRecipients:      bccRecipients,
                Snippet:            &amp;snippet,
                Status:             status,
                IsStarred:          isStarred,
                HasAttachments:     hasAttachments,
                AttachmentCount:    gp.countAttachments(message.Payload),
                SizeEstimate:       &amp;message.SizeEstimate,
                ReceivedAt:         receivedAt,
                Labels:             message.LabelIds,
        }

        return gp.store.StoreGmailMessage(ctx, params)</span>
}

// Helper functions
func (gp *GmailProcessor) getHeaderValue(headers []*gmail.MessagePartHeader, name string) *string <span class="cov8" title="1">{
        for _, header := range headers </span><span class="cov8" title="1">{
                if header.Name == name </span><span class="cov8" title="1">{
                        return &amp;header.Value
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (gp *GmailProcessor) extractRecipients(headers []*gmail.MessagePartHeader, headerName string) []string <span class="cov8" title="1">{
        headerValue := gp.getHeaderValue(headers, headerName)
        if headerValue == nil </span><span class="cov8" title="1">{
                return []string{}
        }</span>

        <span class="cov0" title="0">recipients := strings.Split(*headerValue, ",")
        for i, recipient := range recipients </span><span class="cov0" title="0">{
                recipients[i] = strings.TrimSpace(recipient)
        }</span>
        <span class="cov0" title="0">return recipients</span>
}

func (gp *GmailProcessor) hasLabel(labelIds []string, label string) bool <span class="cov8" title="1">{
        for _, l := range labelIds </span><span class="cov8" title="1">{
                if l == label </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (gp *GmailProcessor) countAttachments(payload *gmail.MessagePart) int <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">count := 0
        if payload.Filename != "" </span><span class="cov0" title="0">{
                count++
        }</span>

        <span class="cov8" title="1">for _, part := range payload.Parts </span><span class="cov0" title="0">{
                count += gp.countAttachments(part)
        }</span>

        <span class="cov8" title="1">return count</span>
}

// Gmail label helpers
func (gp *GmailProcessor) getOrCreateLabel(srv *gmail.Service, name string) (*gmail.Label, error) <span class="cov0" title="0">{
        labels, err := srv.Users.Labels.List("me").Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, label := range labels.Labels </span><span class="cov0" title="0">{
                if label.Name == name </span><span class="cov0" title="0">{
                        return label, nil
                }</span>
        }

        <span class="cov0" title="0">newLabel := &amp;gmail.Label{
                Name:                  name,
                LabelListVisibility:   "labelShow",
                MessageListVisibility: "show",
        }
        return srv.Users.Labels.Create("me", newLabel).Do()</span>
}

func (gp *GmailProcessor) getLabelByName(srv *gmail.Service, name string) (*gmail.Label, error) <span class="cov0" title="0">{
        labels, err := srv.Users.Labels.List("me").Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, label := range labels.Labels </span><span class="cov0" title="0">{
                if label.Name == name </span><span class="cov0" title="0">{
                        return label, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("label not found: %s", name)</span>
}

func (gp *GmailProcessor) createReplyRaw(originalMessage *gmail.Message, replyText, fromEmail string) string <span class="cov0" title="0">{
        subject := gp.getHeaderValue(originalMessage.Payload.Headers, "Subject")
        if subject == nil </span><span class="cov0" title="0">{
                subject = stringPtr("Re:")
        }</span> else<span class="cov0" title="0"> if !strings.HasPrefix(*subject, "Re:") </span><span class="cov0" title="0">{
                subject = stringPtr("Re: " + *subject)
        }</span>

        <span class="cov0" title="0">to := gp.getHeaderValue(originalMessage.Payload.Headers, "From")
        messageID := gp.getHeaderValue(originalMessage.Payload.Headers, "Message-ID")

        rawMessage := fmt.Sprintf(
                "To: %s\r\nFrom: %s\r\nSubject: %s\r\n",
                *to, fromEmail, *subject,
        )

        if messageID != nil </span><span class="cov0" title="0">{
                rawMessage += fmt.Sprintf("References: %s\r\nIn-Reply-To: %s\r\n", *messageID, *messageID)
        }</span>

        <span class="cov0" title="0">rawMessage += "Content-Type: text/plain; charset=UTF-8\r\n\r\n" + replyText

        return base64.URLEncoding.EncodeToString([]byte(rawMessage))</span>
}

// Logging helpers
func (gp *GmailProcessor) logGmailAutomationSuccess(
        ctx context.Context,
        accountID uuid.UUID,
        ruleID *uuid.UUID,
        messageID, threadID, details string,
) <span class="cov8" title="1">{
        params := store.CreateLogParams{
                ConnectedAccountID: accountID,
                RuleID:             ruleID,
                Status:             domain.LogSuccess,
                TriggerDetails: json.RawMessage(
                        fmt.Sprintf(
                                `{"gmail_message_id": %q, "gmail_thread_id": %q}`,
                                messageID,
                                threadID,
                        ),
                ),
                ActionDetails: json.RawMessage(fmt.Sprintf(`{"details": %q}`, details)),
        }
        if err := gp.store.CreateAutomationLog(ctx, params); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create automation log: %v", err)
        }</span>
}

func (gp *GmailProcessor) logGmailAutomationFailure(
        ctx context.Context,
        accountID uuid.UUID,
        ruleID *uuid.UUID,
        messageID, threadID, errorMsg string,
) <span class="cov0" title="0">{
        params := store.CreateLogParams{
                ConnectedAccountID: accountID,
                RuleID:             ruleID,
                Status:             domain.LogFailure,
                TriggerDetails: json.RawMessage(
                        fmt.Sprintf(
                                `{"gmail_message_id": %q, "gmail_thread_id": %q}`,
                                messageID,
                                threadID,
                        ),
                ),
                ErrorMessage: errorMsg,
        }
        if err := gp.store.CreateAutomationLog(ctx, params); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create automation log: %v", err)
        }</span>
}

func stringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package gmail handles Gmail-related background tasks.
package gmail

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strings"

        "agenda-automator-api/internal/domain"

        "google.golang.org/api/gmail/v1"
)

// processMessageAgainstRules applies automation rules to a message.
func (gp *GmailProcessor) processMessageAgainstRules(
        ctx context.Context,
        srv *gmail.Service,
        acc *domain.ConnectedAccount,
        message *gmail.Message,
        rules []domain.GmailAutomationRule,
) error <span class="cov8" title="1">{
        // Store message in database first
        err := gp.storeMessageInDB(ctx, acc, message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not store message: %w", err)
        }</span>

        // Apply each active rule
        <span class="cov8" title="1">for _, rule := range rules </span><span class="cov8" title="1">{
                matches, err := gp.checkRuleMatch(message, rule)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[Gmail] Error checking rule match for rule %s: %v", rule.ID, err)
                        continue</span>
                }

                <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                        log.Printf("[Gmail] Message %s matches rule '%s'", message.Id, rule.Name)
                        err = gp.executeRuleAction(ctx, srv, acc, message, rule)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Gmail] Error executing rule action for rule %s: %v", rule.ID, err)
                                gp.logGmailAutomationFailure(ctx, acc.ID, &amp;rule.ID, message.Id, message.ThreadId, err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                gp.logGmailAutomationSuccess(ctx, acc.ID, &amp;rule.ID, message.Id, message.ThreadId, "Action executed successfully")
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// checkRuleMatch checks if a message matches a rule's trigger conditions
func (gp *GmailProcessor) checkRuleMatch(message *gmail.Message, rule domain.GmailAutomationRule) (bool, error) <span class="cov8" title="1">{
        switch rule.TriggerType </span>{
        case domain.GmailTriggerNewMessage:<span class="cov8" title="1">
                return true, nil</span>

        case domain.GmailTriggerSenderMatch:<span class="cov8" title="1">
                var conditions struct {
                        SenderPattern string `json:"sender_pattern"`
                }
                if err := json.Unmarshal(rule.TriggerConditions, &amp;conditions); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">sender := gp.getHeaderValue(message.Payload.Headers, "From")
                if sender != nil &amp;&amp; strings.Contains(strings.ToLower(*sender), strings.ToLower(conditions.SenderPattern)) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>

        case domain.GmailTriggerSubjectMatch:<span class="cov8" title="1">
                var conditions struct {
                        SubjectPattern string `json:"subject_pattern"`
                }
                if err := json.Unmarshal(rule.TriggerConditions, &amp;conditions); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">subject := gp.getHeaderValue(message.Payload.Headers, "Subject")
                if subject != nil &amp;&amp; strings.Contains(strings.ToLower(*subject), strings.ToLower(conditions.SubjectPattern)) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>

        case domain.GmailTriggerLabelAdded:<span class="cov0" title="0">
                var conditions struct {
                        LabelName string `json:"label_name"`
                }
                if err := json.Unmarshal(rule.TriggerConditions, &amp;conditions); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return gp.hasLabel(message.LabelIds, conditions.LabelName), nil</span>

        case domain.GmailTriggerStarred:<span class="cov8" title="1">
                return gp.hasLabel(message.LabelIds, "STARRED"), nil</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// executeRuleAction executes the action defined by a rule.
func (gp *GmailProcessor) executeRuleAction(
        ctx context.Context,
        srv *gmail.Service,
        acc *domain.ConnectedAccount,
        message *gmail.Message,
        rule domain.GmailAutomationRule,
) error <span class="cov8" title="1">{
        switch rule.ActionType </span>{
        case domain.GmailActionAutoReply:<span class="cov0" title="0">
                return gp.executeAutoReply(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionForward:<span class="cov0" title="0">
                return gp.executeForward(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionAddLabel:<span class="cov0" title="0">
                return gp.executeAddLabel(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionRemoveLabel:<span class="cov0" title="0">
                return gp.executeRemoveLabel(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionMarkRead:<span class="cov8" title="1">
                return gp.executeMarkRead(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionMarkUnread:<span class="cov0" title="0">
                return gp.executeMarkUnread(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionArchive:<span class="cov0" title="0">
                return gp.executeArchive(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionTrash:<span class="cov0" title="0">
                return gp.executeTrash(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionStar:<span class="cov0" title="0">
                return gp.executeStar(ctx, srv, acc, message, rule)</span>

        case domain.GmailActionUnstar:<span class="cov0" title="0">
                return gp.executeUnstar(ctx, srv, acc, message, rule)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unknown action type: %s", rule.ActionType)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package gmail handles Gmail-related background tasks.
package gmail

import (
        "fmt"
        "log"
        "time"

        "agenda-automator-api/internal/domain"

        "google.golang.org/api/gmail/v1"
)

// fetchRecentMessages fetches recent messages for full sync
func (gp *GmailProcessor) fetchRecentMessages(srv *gmail.Service, _ *domain.ConnectedAccount) ([]*gmail.Message, error) <span class="cov8" title="1">{
        oneDayAgo := time.Now().Add(-24 * time.Hour)
        query := fmt.Sprintf("after:%d", oneDayAgo.Unix())

        listCall := srv.Users.Messages.List("me").Q(query).MaxResults(100)
        messages, err := listCall.Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not list messages: %w", err)
        }</span>

        <span class="cov8" title="1">var messageDetails []*gmail.Message
        for _, msg := range messages.Messages </span><span class="cov8" title="1">{
                fullMsg, err := srv.Users.Messages.Get("me", msg.Id).Format("metadata").Do()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[Gmail] Could not fetch message %s: %v", msg.Id, err)
                        continue</span>
                }
                <span class="cov8" title="1">messageDetails = append(messageDetails, fullMsg)</span>
        }

        <span class="cov8" title="1">return messageDetails, nil</span>
}

// processHistoryItems extracts messages from history items.
func (gp *GmailProcessor) processHistoryItems(
        history *gmail.ListHistoryResponse,
        srv *gmail.Service,
) []*gmail.Message <span class="cov0" title="0">{
        var messages []*gmail.Message

        for _, historyItem := range history.History </span><span class="cov0" title="0">{
                for _, msg := range historyItem.Messages </span><span class="cov0" title="0">{
                        fullMsg, err := srv.Users.Messages.Get("me", msg.Id).Format("metadata").Do()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[Gmail] Could not fetch message %s from history: %v", msg.Id, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">messages = append(messages, fullMsg)</span>
                }
        }

        <span class="cov0" title="0">return messages</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package worker

import (
        // "agenda-automator-api/internal/crypto" // &lt;-- VERWIJDERD
        "agenda-automator-api/internal/domain"
        // "agenda-automator-api/internal/logger" // &lt;-- VERWIJDERD (niet meer nodig)
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        "agenda-automator-api/internal/store"
        "agenda-automator-api/internal/worker/calendar"
        "agenda-automator-api/internal/worker/gmail"

        "go.uber.org/zap"
)

// VERWIJDERD:
// var ErrTokenRevoked = fmt.Errorf("token access has been revoked by user")

// Worker is de struct voor onze achtergrond-processor
type Worker struct {
        store             store.Storer
        logger            *zap.Logger
        calendarProcessor *calendar.CalendarProcessor
        gmailProcessor    *gmail.GmailProcessor
        // googleOAuthConfig *oauth2.Config // &lt;-- VERWIJDERD (zit nu in store)
}

// NewWorker (AANGEPAST)
func NewWorker(s store.Storer, logger *zap.Logger) (*Worker, error) <span class="cov8" title="1">{
        return &amp;Worker{
                store:             s,
                logger:            logger,
                calendarProcessor: calendar.NewCalendarProcessor(s),
                gmailProcessor:    gmail.NewGmailProcessor(s),
        }, nil
}</span>

// Start lanceert de worker in een aparte goroutine
func (w *Worker) Start() <span class="cov8" title="1">{
        w.logger.Info("starting worker", zap.String("component", "worker"))

        go w.run()
}</span>

// run is de hoofdloop die periodiek de accounts controleert (real-time monitoring)
func (w *Worker) run() <span class="cov8" title="1">{
        // Verhoogd interval om API-limieten te respecteren
        ticker := time.NewTicker(2 * time.Minute)
        defer ticker.Stop()

        // Draai n keer direct bij het opstarten
        w.doWork()

        for </span><span class="cov8" title="1">{
                &lt;-ticker.C
                w.doWork()
        }</span>
}

// doWork is de daadwerkelijke werklading
func (w *Worker) doWork() <span class="cov8" title="1">{
        w.logger.Info("running work cycle", zap.String("component", "worker"))

        ctx, cancel := context.WithTimeout(context.Background(), 110*time.Second) // Iets korter dan ticker
        defer cancel()

        err := w.checkAccounts(ctx)
        if err != nil </span><span class="cov8" title="1">{
                w.logger.Error("failed to check accounts", zap.Error(err), zap.String("component", "worker"))
        }</span>
}

// checkAccounts haalt alle accounts op, beheert tokens, en start de verwerking (parallel)
func (w *Worker) checkAccounts(ctx context.Context) error <span class="cov8" title="1">{
        accounts, err := w.store.GetActiveAccounts(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not get active accounts: %w", err)
        }</span>

        <span class="cov8" title="1">w.logger.Info(
                "found active accounts to check",
                zap.Int("count", len(accounts)),
                zap.String("component", "worker"),
        )

        var wg sync.WaitGroup
        for i := range accounts </span><span class="cov8" title="1">{
                wg.Add(1)
                acc := &amp;accounts[i]
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        w.processAccount(ctx, acc)
                }</span>()
        }
        <span class="cov8" title="1">wg.Wait()

        return nil</span>
}

// processAccount (ZWAAR VEREENVOUDIGD)
func (w *Worker) processAccount(ctx context.Context, acc *domain.ConnectedAccount) <span class="cov8" title="1">{
        // 1. Haal een gegarandeerd geldig token op.
        // De store regelt de decryptie, check, refresh, en update.
        token, err := w.store.GetValidTokenForAccount(ctx, acc.ID)
        if err != nil </span><span class="cov8" title="1">{
                // De store heeft de 'revoked' status al ingesteld,
                // we hoeven hier alleen nog maar te loggen en stoppen.
                if errors.Is(err, store.ErrTokenRevoked) </span><span class="cov8" title="1">{
                        w.logger.Warn(
                                "account token revoked, stopping processing",
                                zap.String("account_id", acc.ID.String()),
                                zap.String("component", "worker"),
                        )
                }</span> else<span class="cov8" title="1"> {
                        w.logger.Error(
                                "failed to get valid token for account",
                                zap.Error(err),
                                zap.String("account_id", acc.ID.String()),
                                zap.String("component", "worker"),
                        )
                }</span>
                <span class="cov8" title="1">return</span> // Stop verwerking voor dit account
        }

        // 2. Process calendar
        // AANGEPAST: Gebruik w.logger
        <span class="cov8" title="1">w.logger.Info(
                "token valid, processing calendar",
                zap.String("account_id", acc.ID.String()),
                zap.String("component", "worker"),
        )
        if err := w.calendarProcessor.ProcessEvents(ctx, acc, token); err != nil </span><span class="cov0" title="0">{
                // AANGEPAST: Gebruik w.logger
                w.logger.Error(
                        "failed to process calendar events",
                        zap.Error(err),
                        zap.String("account_id", acc.ID.String()),
                        zap.String("component", "worker"),
                )
        }</span>

        // 2.5. Process Gmail (only if Gmail sync is enabled)
        <span class="cov8" title="1">if acc.GmailSyncEnabled </span><span class="cov0" title="0">{
                // AANGEPAST: Gebruik w.logger
                w.logger.Info(
                        "processing Gmail messages",
                        zap.String("account_id", acc.ID.String()),
                        zap.String("component", "worker"),
                )
                if err := w.gmailProcessor.ProcessMessages(ctx, acc, token); err != nil </span><span class="cov0" title="0">{
                        // AANGEPAST: Gebruik w.logger
                        w.logger.Error(
                                "failed to process Gmail messages",
                                zap.Error(err),
                                zap.String("account_id", acc.ID.String()),
                                zap.String("component", "worker"),
                        )
                }</span>
        }

        // 3. Update last_checked
        <span class="cov8" title="1">if err := w.store.UpdateAccountLastChecked(ctx, acc.ID); err != nil </span><span class="cov8" title="1">{
                // AANGEPAST: Gebruik w.logger
                w.logger.Error(
                        "failed to update last_checked timestamp",
                        zap.Error(err),
                        zap.String("account_id", acc.ID.String()),
                        zap.String("component", "worker"),
                )
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
